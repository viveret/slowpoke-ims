/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@stackoverflow/stacks/dist/js/stacks.js":
/*!**************************************************************!*\
  !*** ./node_modules/@stackoverflow/stacks/dist/js/stacks.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(globalThis, () => {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 492:\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_533__) => {\n\n// ESM COMPAT FLAG\n__nested_webpack_require_533__.r(__webpack_exports__);\n\n// EXPORTS\n__nested_webpack_require_533__.d(__webpack_exports__, {\n  \"afterMain\": () => (/* reexport */ afterMain),\n  \"afterRead\": () => (/* reexport */ afterRead),\n  \"afterWrite\": () => (/* reexport */ afterWrite),\n  \"applyStyles\": () => (/* reexport */ modifiers_applyStyles),\n  \"arrow\": () => (/* reexport */ modifiers_arrow),\n  \"auto\": () => (/* reexport */ auto),\n  \"basePlacements\": () => (/* reexport */ basePlacements),\n  \"beforeMain\": () => (/* reexport */ beforeMain),\n  \"beforeRead\": () => (/* reexport */ beforeRead),\n  \"beforeWrite\": () => (/* reexport */ beforeWrite),\n  \"bottom\": () => (/* reexport */ bottom),\n  \"clippingParents\": () => (/* reexport */ clippingParents),\n  \"computeStyles\": () => (/* reexport */ modifiers_computeStyles),\n  \"createPopper\": () => (/* reexport */ popper_createPopper),\n  \"createPopperBase\": () => (/* reexport */ createPopper),\n  \"createPopperLite\": () => (/* reexport */ popper_lite_createPopper),\n  \"detectOverflow\": () => (/* reexport */ detectOverflow),\n  \"end\": () => (/* reexport */ end),\n  \"eventListeners\": () => (/* reexport */ eventListeners),\n  \"flip\": () => (/* reexport */ modifiers_flip),\n  \"hide\": () => (/* reexport */ modifiers_hide),\n  \"left\": () => (/* reexport */ left),\n  \"main\": () => (/* reexport */ main),\n  \"modifierPhases\": () => (/* reexport */ modifierPhases),\n  \"offset\": () => (/* reexport */ modifiers_offset),\n  \"placements\": () => (/* reexport */ enums_placements),\n  \"popper\": () => (/* reexport */ popper),\n  \"popperGenerator\": () => (/* reexport */ popperGenerator),\n  \"popperOffsets\": () => (/* reexport */ modifiers_popperOffsets),\n  \"preventOverflow\": () => (/* reexport */ modifiers_preventOverflow),\n  \"read\": () => (/* reexport */ read),\n  \"reference\": () => (/* reexport */ reference),\n  \"right\": () => (/* reexport */ right),\n  \"start\": () => (/* reexport */ start),\n  \"top\": () => (/* reexport */ enums_top),\n  \"variationPlacements\": () => (/* reexport */ variationPlacements),\n  \"viewport\": () => (/* reexport */ viewport),\n  \"write\": () => (/* reexport */ write)\n});\n\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/enums.js\nvar enums_top = 'top';\nvar bottom = 'bottom';\nvar right = 'right';\nvar left = 'left';\nvar auto = 'auto';\nvar basePlacements = [enums_top, bottom, right, left];\nvar start = 'start';\nvar end = 'end';\nvar clippingParents = 'clippingParents';\nvar viewport = 'viewport';\nvar popper = 'popper';\nvar reference = 'reference';\nvar variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {\n  return acc.concat([placement + \"-\" + start, placement + \"-\" + end]);\n}, []);\nvar enums_placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {\n  return acc.concat([placement, placement + \"-\" + start, placement + \"-\" + end]);\n}, []); // modifiers that need to read the DOM\n\nvar beforeRead = 'beforeRead';\nvar read = 'read';\nvar afterRead = 'afterRead'; // pure-logic modifiers\n\nvar beforeMain = 'beforeMain';\nvar main = 'main';\nvar afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)\n\nvar beforeWrite = 'beforeWrite';\nvar write = 'write';\nvar afterWrite = 'afterWrite';\nvar modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\nfunction getNodeName(element) {\n  return element ? (element.nodeName || '').toLowerCase() : null;\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n\n  if (node.toString() !== '[object Window]') {\n    var ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\n\n\nfunction isElement(node) {\n  var OwnElement = getWindow(node).Element;\n  return node instanceof OwnElement || node instanceof Element;\n}\n\nfunction isHTMLElement(node) {\n  var OwnElement = getWindow(node).HTMLElement;\n  return node instanceof OwnElement || node instanceof HTMLElement;\n}\n\nfunction isShadowRoot(node) {\n  // IE 11 has no ShadowRoot\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n\n  var OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\n\n\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/applyStyles.js\n\n // This modifier takes the styles prepared by the `computeStyles` modifier\n// and applies them to the HTMLElements such as popper and arrow\n\nfunction applyStyles(_ref) {\n  var state = _ref.state;\n  Object.keys(state.elements).forEach(function (name) {\n    var style = state.styles[name] || {};\n    var attributes = state.attributes[name] || {};\n    var element = state.elements[name]; // arrow is optional + virtual elements\n\n    if (!isHTMLElement(element) || !getNodeName(element)) {\n      return;\n    } // Flow doesn't support to extend this property, but it's the most\n    // effective way to apply styles to an HTMLElement\n    // $FlowFixMe[cannot-write]\n\n\n    Object.assign(element.style, style);\n    Object.keys(attributes).forEach(function (name) {\n      var value = attributes[name];\n\n      if (value === false) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, value === true ? '' : value);\n      }\n    });\n  });\n}\n\nfunction effect(_ref2) {\n  var state = _ref2.state;\n  var initialStyles = {\n    popper: {\n      position: state.options.strategy,\n      left: '0',\n      top: '0',\n      margin: '0'\n    },\n    arrow: {\n      position: 'absolute'\n    },\n    reference: {}\n  };\n  Object.assign(state.elements.popper.style, initialStyles.popper);\n  state.styles = initialStyles;\n\n  if (state.elements.arrow) {\n    Object.assign(state.elements.arrow.style, initialStyles.arrow);\n  }\n\n  return function () {\n    Object.keys(state.elements).forEach(function (name) {\n      var element = state.elements[name];\n      var attributes = state.attributes[name] || {};\n      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n\n      var style = styleProperties.reduce(function (style, property) {\n        style[property] = '';\n        return style;\n      }, {}); // arrow is optional + virtual elements\n\n      if (!isHTMLElement(element) || !getNodeName(element)) {\n        return;\n      }\n\n      Object.assign(element.style, style);\n      Object.keys(attributes).forEach(function (attribute) {\n        element.removeAttribute(attribute);\n      });\n    });\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const modifiers_applyStyles = ({\n  name: 'applyStyles',\n  enabled: true,\n  phase: 'write',\n  fn: applyStyles,\n  effect: effect,\n  requires: ['computeStyles']\n});\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getBasePlacement.js\n\nfunction getBasePlacement(placement) {\n  return placement.split('-')[0];\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/math.js\nvar math_max = Math.max;\nvar math_min = Math.min;\nvar round = Math.round;\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/userAgent.js\nfunction getUAString() {\n  var uaData = navigator.userAgentData;\n\n  if (uaData != null && uaData.brands) {\n    return uaData.brands.map(function (item) {\n      return item.brand + \"/\" + item.version;\n    }).join(' ');\n  }\n\n  return navigator.userAgent;\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js\n\nfunction isLayoutViewport() {\n  return !/^((?!chrome|android).)*safari/i.test(getUAString());\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js\n\n\n\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n\n  var clientRect = element.getBoundingClientRect();\n  var scaleX = 1;\n  var scaleY = 1;\n\n  if (includeScale && isHTMLElement(element)) {\n    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n\n  var _ref = isElement(element) ? getWindow(element) : window,\n      visualViewport = _ref.visualViewport;\n\n  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;\n  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;\n  var width = clientRect.width / scaleX;\n  var height = clientRect.height / scaleY;\n  return {\n    width: width,\n    height: height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x: x,\n    y: y\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js\n // Returns the layout rect of an element relative to its offsetParent. Layout\n// means it doesn't take into account transforms.\n\nfunction getLayoutRect(element) {\n  var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.\n  // Fixes https://github.com/popperjs/popper-core/issues/1223\n\n  var width = element.offsetWidth;\n  var height = element.offsetHeight;\n\n  if (Math.abs(clientRect.width - width) <= 1) {\n    width = clientRect.width;\n  }\n\n  if (Math.abs(clientRect.height - height) <= 1) {\n    height = clientRect.height;\n  }\n\n  return {\n    x: element.offsetLeft,\n    y: element.offsetTop,\n    width: width,\n    height: height\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/contains.js\n\nfunction contains(parent, child) {\n  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n      var next = child;\n\n      do {\n        if (next && parent.isSameNode(next)) {\n          return true;\n        } // $FlowFixMe[prop-missing]: need a better way to handle this...\n\n\n        next = next.parentNode || next.host;\n      } while (next);\n    } // Give up, the result is false\n\n\n  return false;\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js\n\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js\n\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\n\nfunction getDocumentElement(element) {\n  // $FlowFixMe[incompatible-return]: assume body is always available\n  return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]\n  element.document) || window.document).documentElement;\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js\n\n\n\nfunction getParentNode(element) {\n  if (getNodeName(element) === 'html') {\n    return element;\n  }\n\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // $FlowFixMe[incompatible-return]\n    // $FlowFixMe[prop-missing]\n    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    element.parentNode || ( // DOM Element detected\n    isShadowRoot(element) ? element.host : null) || // ShadowRoot detected\n    // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n    getDocumentElement(element) // fallback\n\n  );\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js\n\n\n\n\n\n\n\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837\n  getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n\n  return element.offsetParent;\n} // `.offsetParent` reports `null` for fixed elements, while absolute elements\n// return the containing block\n\n\nfunction getContainingBlock(element) {\n  var isFirefox = /firefox/i.test(getUAString());\n  var isIE = /Trident/i.test(getUAString());\n\n  if (isIE && isHTMLElement(element)) {\n    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport\n    var elementCss = getComputedStyle(element);\n\n    if (elementCss.position === 'fixed') {\n      return null;\n    }\n  }\n\n  var currentNode = getParentNode(element);\n\n  if (isShadowRoot(currentNode)) {\n    currentNode = currentNode.host;\n  }\n\n  while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {\n    var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that\n    // create a containing block.\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nfunction getOffsetParent(element) {\n  var window = getWindow(element);\n  var offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/within.js\n\nfunction within(min, value, max) {\n  return math_max(min, math_min(value, max));\n}\nfunction withinMaxClamp(min, value, max) {\n  var v = within(min, value, max);\n  return v > max ? max : v;\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js\nfunction getFreshSideObject() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js\n\nfunction mergePaddingObject(paddingObject) {\n  return Object.assign({}, getFreshSideObject(), paddingObject);\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/expandToHashMap.js\nfunction expandToHashMap(value, keys) {\n  return keys.reduce(function (hashMap, key) {\n    hashMap[key] = value;\n    return hashMap;\n  }, {});\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/arrow.js\n\n\n\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nvar toPaddingObject = function toPaddingObject(padding, state) {\n  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : padding;\n  return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n};\n\nfunction arrow(_ref) {\n  var _state$modifiersData$;\n\n  var state = _ref.state,\n      name = _ref.name,\n      options = _ref.options;\n  var arrowElement = state.elements.arrow;\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var basePlacement = getBasePlacement(state.placement);\n  var axis = getMainAxisFromPlacement(basePlacement);\n  var isVertical = [left, right].indexOf(basePlacement) >= 0;\n  var len = isVertical ? 'height' : 'width';\n\n  if (!arrowElement || !popperOffsets) {\n    return;\n  }\n\n  var paddingObject = toPaddingObject(options.padding, state);\n  var arrowRect = getLayoutRect(arrowElement);\n  var minProp = axis === 'y' ? enums_top : left;\n  var maxProp = axis === 'y' ? bottom : right;\n  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n  var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n  var arrowOffsetParent = getOffsetParent(arrowElement);\n  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n  // outside of the popper bounds\n\n  var min = paddingObject[minProp];\n  var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n  var offset = within(min, center, max); // Prevents breaking syntax highlighting...\n\n  var axisProp = axis;\n  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\n}\n\nfunction arrow_effect(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options;\n  var _options$element = options.element,\n      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;\n\n  if (arrowElement == null) {\n    return;\n  } // CSS selector\n\n\n  if (typeof arrowElement === 'string') {\n    arrowElement = state.elements.popper.querySelector(arrowElement);\n\n    if (!arrowElement) {\n      return;\n    }\n  }\n\n  if (false) {}\n\n  if (!contains(state.elements.popper, arrowElement)) {\n    if (false) {}\n\n    return;\n  }\n\n  state.elements.arrow = arrowElement;\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const modifiers_arrow = ({\n  name: 'arrow',\n  enabled: true,\n  phase: 'main',\n  fn: arrow,\n  effect: arrow_effect,\n  requires: ['popperOffsets'],\n  requiresIfExists: ['preventOverflow']\n});\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getVariation.js\nfunction getVariation(placement) {\n  return placement.split('-')[1];\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/computeStyles.js\n\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nvar unsetSides = {\n  top: 'auto',\n  right: 'auto',\n  bottom: 'auto',\n  left: 'auto'\n}; // Round the offsets to the nearest suitable subpixel based on the DPR.\n// Zooming can change the DPR, but it seems to report a value that will\n// cleanly divide the values into the appropriate subpixels.\n\nfunction roundOffsetsByDPR(_ref) {\n  var x = _ref.x,\n      y = _ref.y;\n  var win = window;\n  var dpr = win.devicePixelRatio || 1;\n  return {\n    x: round(x * dpr) / dpr || 0,\n    y: round(y * dpr) / dpr || 0\n  };\n}\n\nfunction mapToStyles(_ref2) {\n  var _Object$assign2;\n\n  var popper = _ref2.popper,\n      popperRect = _ref2.popperRect,\n      placement = _ref2.placement,\n      variation = _ref2.variation,\n      offsets = _ref2.offsets,\n      position = _ref2.position,\n      gpuAcceleration = _ref2.gpuAcceleration,\n      adaptive = _ref2.adaptive,\n      roundOffsets = _ref2.roundOffsets,\n      isFixed = _ref2.isFixed;\n  var _offsets$x = offsets.x,\n      x = _offsets$x === void 0 ? 0 : _offsets$x,\n      _offsets$y = offsets.y,\n      y = _offsets$y === void 0 ? 0 : _offsets$y;\n\n  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({\n    x: x,\n    y: y\n  }) : {\n    x: x,\n    y: y\n  };\n\n  x = _ref3.x;\n  y = _ref3.y;\n  var hasX = offsets.hasOwnProperty('x');\n  var hasY = offsets.hasOwnProperty('y');\n  var sideX = left;\n  var sideY = enums_top;\n  var win = window;\n\n  if (adaptive) {\n    var offsetParent = getOffsetParent(popper);\n    var heightProp = 'clientHeight';\n    var widthProp = 'clientWidth';\n\n    if (offsetParent === getWindow(popper)) {\n      offsetParent = getDocumentElement(popper);\n\n      if (getComputedStyle(offsetParent).position !== 'static' && position === 'absolute') {\n        heightProp = 'scrollHeight';\n        widthProp = 'scrollWidth';\n      }\n    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n\n\n    offsetParent = offsetParent;\n\n    if (placement === enums_top || (placement === left || placement === right) && variation === end) {\n      sideY = bottom;\n      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]\n      offsetParent[heightProp];\n      y -= offsetY - popperRect.height;\n      y *= gpuAcceleration ? 1 : -1;\n    }\n\n    if (placement === left || (placement === enums_top || placement === bottom) && variation === end) {\n      sideX = right;\n      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]\n      offsetParent[widthProp];\n      x -= offsetX - popperRect.width;\n      x *= gpuAcceleration ? 1 : -1;\n    }\n  }\n\n  var commonStyles = Object.assign({\n    position: position\n  }, adaptive && unsetSides);\n\n  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({\n    x: x,\n    y: y\n  }) : {\n    x: x,\n    y: y\n  };\n\n  x = _ref4.x;\n  y = _ref4.y;\n\n  if (gpuAcceleration) {\n    var _Object$assign;\n\n    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n  }\n\n  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : '', _Object$assign2[sideX] = hasX ? x + \"px\" : '', _Object$assign2.transform = '', _Object$assign2));\n}\n\nfunction computeStyles(_ref5) {\n  var state = _ref5.state,\n      options = _ref5.options;\n  var _options$gpuAccelerat = options.gpuAcceleration,\n      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,\n      _options$adaptive = options.adaptive,\n      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,\n      _options$roundOffsets = options.roundOffsets,\n      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n\n  if (false) { var transitionProperty; }\n\n  var commonStyles = {\n    placement: getBasePlacement(state.placement),\n    variation: getVariation(state.placement),\n    popper: state.elements.popper,\n    popperRect: state.rects.popper,\n    gpuAcceleration: gpuAcceleration,\n    isFixed: state.options.strategy === 'fixed'\n  };\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.popperOffsets,\n      position: state.options.strategy,\n      adaptive: adaptive,\n      roundOffsets: roundOffsets\n    })));\n  }\n\n  if (state.modifiersData.arrow != null) {\n    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.arrow,\n      position: 'absolute',\n      adaptive: false,\n      roundOffsets: roundOffsets\n    })));\n  }\n\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    'data-popper-placement': state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const modifiers_computeStyles = ({\n  name: 'computeStyles',\n  enabled: true,\n  phase: 'beforeWrite',\n  fn: computeStyles,\n  data: {}\n});\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/eventListeners.js\n // eslint-disable-next-line import/no-unused-modules\n\nvar passive = {\n  passive: true\n};\n\nfunction eventListeners_effect(_ref) {\n  var state = _ref.state,\n      instance = _ref.instance,\n      options = _ref.options;\n  var _options$scroll = options.scroll,\n      scroll = _options$scroll === void 0 ? true : _options$scroll,\n      _options$resize = options.resize,\n      resize = _options$resize === void 0 ? true : _options$resize;\n  var window = getWindow(state.elements.popper);\n  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n\n  if (scroll) {\n    scrollParents.forEach(function (scrollParent) {\n      scrollParent.addEventListener('scroll', instance.update, passive);\n    });\n  }\n\n  if (resize) {\n    window.addEventListener('resize', instance.update, passive);\n  }\n\n  return function () {\n    if (scroll) {\n      scrollParents.forEach(function (scrollParent) {\n        scrollParent.removeEventListener('scroll', instance.update, passive);\n      });\n    }\n\n    if (resize) {\n      window.removeEventListener('resize', instance.update, passive);\n    }\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const eventListeners = ({\n  name: 'eventListeners',\n  enabled: true,\n  phase: 'write',\n  fn: function fn() {},\n  effect: eventListeners_effect,\n  data: {}\n});\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js\nvar hash = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js\nvar getOppositeVariationPlacement_hash = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeVariationPlacement(placement) {\n  return placement.replace(/start|end/g, function (matched) {\n    return getOppositeVariationPlacement_hash[matched];\n  });\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js\n\nfunction getWindowScroll(node) {\n  var win = getWindow(node);\n  var scrollLeft = win.pageXOffset;\n  var scrollTop = win.pageYOffset;\n  return {\n    scrollLeft: scrollLeft,\n    scrollTop: scrollTop\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js\n\n\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  // Popper 1 is broken in this case and never had a bug report so let's assume\n  // it's not an issue. I don't think anyone ever specifies width on <html>\n  // anyway.\n  // Browsers where the left scrollbar doesn't cause an issue report `0` for\n  // this (e.g. Edge 2019, IE11, Safari)\n  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js\n\n\n\n\nfunction getViewportRect(element, strategy) {\n  var win = getWindow(element);\n  var html = getDocumentElement(element);\n  var visualViewport = win.visualViewport;\n  var width = html.clientWidth;\n  var height = html.clientHeight;\n  var x = 0;\n  var y = 0;\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    var layoutViewport = isLayoutViewport();\n\n    if (layoutViewport || !layoutViewport && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: x + getWindowScrollBarX(element),\n    y: y\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js\n\n\n\n\n // Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n\n  var html = getDocumentElement(element);\n  var winScroll = getWindowScroll(element);\n  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  var width = math_max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  var height = math_max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);\n  var y = -winScroll.scrollTop;\n\n  if (getComputedStyle(body || html).direction === 'rtl') {\n    x += math_max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: x,\n    y: y\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js\n\nfunction isScrollParent(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  var _getComputedStyle = getComputedStyle(element),\n      overflow = _getComputedStyle.overflow,\n      overflowX = _getComputedStyle.overflowX,\n      overflowY = _getComputedStyle.overflowY;\n\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js\n\n\n\n\nfunction getScrollParent(node) {\n  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {\n    // $FlowFixMe[incompatible-return]: assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(node) && isScrollParent(node)) {\n    return node;\n  }\n\n  return getScrollParent(getParentNode(node));\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js\n\n\n\n\n/*\ngiven a DOM element, return the list of all scroll parents, up the list of ancesors\nuntil we get to the top window object. This list is what we attach scroll listeners\nto, because if any of these parent elements scroll, we'll need to re-calculate the\nreference element's position.\n*/\n\nfunction listScrollParents(element, list) {\n  var _element$ownerDocumen;\n\n  if (list === void 0) {\n    list = [];\n  }\n\n  var scrollParent = getScrollParent(element);\n  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\n  var win = getWindow(scrollParent);\n  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n  var updatedList = list.concat(target);\n  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n  updatedList.concat(listScrollParents(getParentNode(target)));\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/rectToClientRect.js\nfunction rectToClientRect(rect) {\n  return Object.assign({}, rect, {\n    left: rect.x,\n    top: rect.y,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  });\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction getInnerBoundingClientRect(element, strategy) {\n  var rect = getBoundingClientRect(element, false, strategy === 'fixed');\n  rect.top = rect.top + element.clientTop;\n  rect.left = rect.left + element.clientLeft;\n  rect.bottom = rect.top + element.clientHeight;\n  rect.right = rect.left + element.clientWidth;\n  rect.width = element.clientWidth;\n  rect.height = element.clientHeight;\n  rect.x = rect.left;\n  rect.y = rect.top;\n  return rect;\n}\n\nfunction getClientRectFromMixedType(element, clippingParent, strategy) {\n  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingParents(element) {\n  var clippingParents = listScrollParents(getParentNode(element));\n  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;\n  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414\n\n\n  return clippingParents.filter(function (clippingParent) {\n    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';\n  });\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping parents\n\n\nfunction getClippingRect(element, boundary, rootBoundary, strategy) {\n  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);\n  var firstClippingParent = clippingParents[0];\n  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\n    var rect = getClientRectFromMixedType(element, clippingParent, strategy);\n    accRect.top = math_max(rect.top, accRect.top);\n    accRect.right = math_min(rect.right, accRect.right);\n    accRect.bottom = math_min(rect.bottom, accRect.bottom);\n    accRect.left = math_max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromMixedType(element, firstClippingParent, strategy));\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n  return clippingRect;\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/computeOffsets.js\n\n\n\n\nfunction computeOffsets(_ref) {\n  var reference = _ref.reference,\n      element = _ref.element,\n      placement = _ref.placement;\n  var basePlacement = placement ? getBasePlacement(placement) : null;\n  var variation = placement ? getVariation(placement) : null;\n  var commonX = reference.x + reference.width / 2 - element.width / 2;\n  var commonY = reference.y + reference.height / 2 - element.height / 2;\n  var offsets;\n\n  switch (basePlacement) {\n    case enums_top:\n      offsets = {\n        x: commonX,\n        y: reference.y - element.height\n      };\n      break;\n\n    case bottom:\n      offsets = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case right:\n      offsets = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case left:\n      offsets = {\n        x: reference.x - element.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      offsets = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n\n  if (mainAxis != null) {\n    var len = mainAxis === 'y' ? 'height' : 'width';\n\n    switch (variation) {\n      case start:\n        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);\n        break;\n\n      case end:\n        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);\n        break;\n\n      default:\n    }\n  }\n\n  return offsets;\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/detectOverflow.js\n\n\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nfunction detectOverflow(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$placement = _options.placement,\n      placement = _options$placement === void 0 ? state.placement : _options$placement,\n      _options$strategy = _options.strategy,\n      strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,\n      _options$boundary = _options.boundary,\n      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,\n      _options$rootBoundary = _options.rootBoundary,\n      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,\n      _options$elementConte = _options.elementContext,\n      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,\n      _options$altBoundary = _options.altBoundary,\n      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\n      _options$padding = _options.padding,\n      padding = _options$padding === void 0 ? 0 : _options$padding;\n  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n  var altContext = elementContext === popper ? reference : popper;\n  var popperRect = state.rects.popper;\n  var element = state.elements[altBoundary ? altContext : elementContext];\n  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);\n  var referenceClientRect = getBoundingClientRect(state.elements.reference);\n  var popperOffsets = computeOffsets({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: 'absolute',\n    placement: placement\n  });\n  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));\n  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n\n  var overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n\n  if (elementContext === popper && offsetData) {\n    var offset = offsetData[placement];\n    Object.keys(overflowOffsets).forEach(function (key) {\n      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n      var axis = [enums_top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n      overflowOffsets[key] += offset[axis] * multiply;\n    });\n  }\n\n  return overflowOffsets;\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js\n\n\n\n\nfunction computeAutoPlacement(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      placement = _options.placement,\n      boundary = _options.boundary,\n      rootBoundary = _options.rootBoundary,\n      padding = _options.padding,\n      flipVariations = _options.flipVariations,\n      _options$allowedAutoP = _options.allowedAutoPlacements,\n      allowedAutoPlacements = _options$allowedAutoP === void 0 ? enums_placements : _options$allowedAutoP;\n  var variation = getVariation(placement);\n  var placements = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {\n    return getVariation(placement) === variation;\n  }) : basePlacements;\n  var allowedPlacements = placements.filter(function (placement) {\n    return allowedAutoPlacements.indexOf(placement) >= 0;\n  });\n\n  if (allowedPlacements.length === 0) {\n    allowedPlacements = placements;\n\n    if (false) {}\n  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...\n\n\n  var overflows = allowedPlacements.reduce(function (acc, placement) {\n    acc[placement] = detectOverflow(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding\n    })[getBasePlacement(placement)];\n    return acc;\n  }, {});\n  return Object.keys(overflows).sort(function (a, b) {\n    return overflows[a] - overflows[b];\n  });\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/flip.js\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nfunction getExpandedFallbackPlacements(placement) {\n  if (getBasePlacement(placement) === auto) {\n    return [];\n  }\n\n  var oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n}\n\nfunction flip(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n\n  if (state.modifiersData[name]._skip) {\n    return;\n  }\n\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,\n      specifiedFallbackPlacements = options.fallbackPlacements,\n      padding = options.padding,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      _options$flipVariatio = options.flipVariations,\n      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\n      allowedAutoPlacements = options.allowedAutoPlacements;\n  var preferredPlacement = state.options.placement;\n  var basePlacement = getBasePlacement(preferredPlacement);\n  var isBasePlacement = basePlacement === preferredPlacement;\n  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {\n    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding,\n      flipVariations: flipVariations,\n      allowedAutoPlacements: allowedAutoPlacements\n    }) : placement);\n  }, []);\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var checksMap = new Map();\n  var makeFallbackChecks = true;\n  var firstFittingPlacement = placements[0];\n\n  for (var i = 0; i < placements.length; i++) {\n    var placement = placements[i];\n\n    var _basePlacement = getBasePlacement(placement);\n\n    var isStartVariation = getVariation(placement) === start;\n    var isVertical = [enums_top, bottom].indexOf(_basePlacement) >= 0;\n    var len = isVertical ? 'width' : 'height';\n    var overflow = detectOverflow(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      altBoundary: altBoundary,\n      padding: padding\n    });\n    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : enums_top;\n\n    if (referenceRect[len] > popperRect[len]) {\n      mainVariationSide = getOppositePlacement(mainVariationSide);\n    }\n\n    var altVariationSide = getOppositePlacement(mainVariationSide);\n    var checks = [];\n\n    if (checkMainAxis) {\n      checks.push(overflow[_basePlacement] <= 0);\n    }\n\n    if (checkAltAxis) {\n      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n    }\n\n    if (checks.every(function (check) {\n      return check;\n    })) {\n      firstFittingPlacement = placement;\n      makeFallbackChecks = false;\n      break;\n    }\n\n    checksMap.set(placement, checks);\n  }\n\n  if (makeFallbackChecks) {\n    // `2` may be desired in some cases â€“ research later\n    var numberOfChecks = flipVariations ? 3 : 1;\n\n    var _loop = function _loop(_i) {\n      var fittingPlacement = placements.find(function (placement) {\n        var checks = checksMap.get(placement);\n\n        if (checks) {\n          return checks.slice(0, _i).every(function (check) {\n            return check;\n          });\n        }\n      });\n\n      if (fittingPlacement) {\n        firstFittingPlacement = fittingPlacement;\n        return \"break\";\n      }\n    };\n\n    for (var _i = numberOfChecks; _i > 0; _i--) {\n      var _ret = _loop(_i);\n\n      if (_ret === \"break\") break;\n    }\n  }\n\n  if (state.placement !== firstFittingPlacement) {\n    state.modifiersData[name]._skip = true;\n    state.placement = firstFittingPlacement;\n    state.reset = true;\n  }\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const modifiers_flip = ({\n  name: 'flip',\n  enabled: true,\n  phase: 'main',\n  fn: flip,\n  requiresIfExists: ['offset'],\n  data: {\n    _skip: false\n  }\n});\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/hide.js\n\n\n\nfunction getSideOffsets(overflow, rect, preventedOffsets) {\n  if (preventedOffsets === void 0) {\n    preventedOffsets = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  return {\n    top: overflow.top - rect.height - preventedOffsets.y,\n    right: overflow.right - rect.width + preventedOffsets.x,\n    bottom: overflow.bottom - rect.height + preventedOffsets.y,\n    left: overflow.left - rect.width - preventedOffsets.x\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return [enums_top, right, bottom, left].some(function (side) {\n    return overflow[side] >= 0;\n  });\n}\n\nfunction hide(_ref) {\n  var state = _ref.state,\n      name = _ref.name;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var preventedOffsets = state.modifiersData.preventOverflow;\n  var referenceOverflow = detectOverflow(state, {\n    elementContext: 'reference'\n  });\n  var popperAltOverflow = detectOverflow(state, {\n    altBoundary: true\n  });\n  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n  state.modifiersData[name] = {\n    referenceClippingOffsets: referenceClippingOffsets,\n    popperEscapeOffsets: popperEscapeOffsets,\n    isReferenceHidden: isReferenceHidden,\n    hasPopperEscaped: hasPopperEscaped\n  };\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    'data-popper-reference-hidden': isReferenceHidden,\n    'data-popper-escaped': hasPopperEscaped\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const modifiers_hide = ({\n  name: 'hide',\n  enabled: true,\n  phase: 'main',\n  requiresIfExists: ['preventOverflow'],\n  fn: hide\n});\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/offset.js\n\n // eslint-disable-next-line import/no-unused-modules\n\nfunction distanceAndSkiddingToXY(placement, rects, offset) {\n  var basePlacement = getBasePlacement(placement);\n  var invertDistance = [left, enums_top].indexOf(basePlacement) >= 0 ? -1 : 1;\n\n  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {\n    placement: placement\n  })) : offset,\n      skidding = _ref[0],\n      distance = _ref[1];\n\n  skidding = skidding || 0;\n  distance = (distance || 0) * invertDistance;\n  return [left, right].indexOf(basePlacement) >= 0 ? {\n    x: distance,\n    y: skidding\n  } : {\n    x: skidding,\n    y: distance\n  };\n}\n\nfunction offset(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options,\n      name = _ref2.name;\n  var _options$offset = options.offset,\n      offset = _options$offset === void 0 ? [0, 0] : _options$offset;\n  var data = enums_placements.reduce(function (acc, placement) {\n    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n    return acc;\n  }, {});\n  var _data$state$placement = data[state.placement],\n      x = _data$state$placement.x,\n      y = _data$state$placement.y;\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.modifiersData.popperOffsets.x += x;\n    state.modifiersData.popperOffsets.y += y;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const modifiers_offset = ({\n  name: 'offset',\n  enabled: true,\n  phase: 'main',\n  requires: ['popperOffsets'],\n  fn: offset\n});\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js\n\n\nfunction popperOffsets(_ref) {\n  var state = _ref.state,\n      name = _ref.name;\n  // Offsets are the actual position the popper needs to have to be\n  // properly positioned near its reference element\n  // This is the most basic placement, and will be adjusted by\n  // the modifiers in the next step\n  state.modifiersData[name] = computeOffsets({\n    reference: state.rects.reference,\n    element: state.rects.popper,\n    strategy: 'absolute',\n    placement: state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const modifiers_popperOffsets = ({\n  name: 'popperOffsets',\n  enabled: true,\n  phase: 'read',\n  fn: popperOffsets,\n  data: {}\n});\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getAltAxis.js\nfunction getAltAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js\n\n\n\n\n\n\n\n\n\n\n\n\nfunction preventOverflow(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      padding = options.padding,\n      _options$tether = options.tether,\n      tether = _options$tether === void 0 ? true : _options$tether,\n      _options$tetherOffset = options.tetherOffset,\n      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n  var overflow = detectOverflow(state, {\n    boundary: boundary,\n    rootBoundary: rootBoundary,\n    padding: padding,\n    altBoundary: altBoundary\n  });\n  var basePlacement = getBasePlacement(state.placement);\n  var variation = getVariation(state.placement);\n  var isBasePlacement = !variation;\n  var mainAxis = getMainAxisFromPlacement(basePlacement);\n  var altAxis = getAltAxis(mainAxis);\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : tetherOffset;\n  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {\n    mainAxis: tetherOffsetValue,\n    altAxis: tetherOffsetValue\n  } : Object.assign({\n    mainAxis: 0,\n    altAxis: 0\n  }, tetherOffsetValue);\n  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\n  var data = {\n    x: 0,\n    y: 0\n  };\n\n  if (!popperOffsets) {\n    return;\n  }\n\n  if (checkMainAxis) {\n    var _offsetModifierState$;\n\n    var mainSide = mainAxis === 'y' ? enums_top : left;\n    var altSide = mainAxis === 'y' ? bottom : right;\n    var len = mainAxis === 'y' ? 'height' : 'width';\n    var offset = popperOffsets[mainAxis];\n    var min = offset + overflow[mainSide];\n    var max = offset - overflow[altSide];\n    var additive = tether ? -popperRect[len] / 2 : 0;\n    var minLen = variation === start ? referenceRect[len] : popperRect[len];\n    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n    // outside the reference bounds\n\n    var arrowElement = state.elements.arrow;\n    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n      width: 0,\n      height: 0\n    };\n    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n    var arrowPaddingMin = arrowPaddingObject[mainSide];\n    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n    // to include its full size in the calculation. If the reference is small\n    // and near the edge of a boundary, the popper can overflow even if the\n    // reference is not overflowing as well (e.g. virtual elements with no\n    // width or height)\n\n    var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\n    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\n    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\n    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;\n    var tetherMax = offset + maxOffset - offsetModifierValue;\n    var preventedOffset = within(tether ? math_min(min, tetherMin) : min, offset, tether ? math_max(max, tetherMax) : max);\n    popperOffsets[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset;\n  }\n\n  if (checkAltAxis) {\n    var _offsetModifierState$2;\n\n    var _mainSide = mainAxis === 'x' ? enums_top : left;\n\n    var _altSide = mainAxis === 'x' ? bottom : right;\n\n    var _offset = popperOffsets[altAxis];\n\n    var _len = altAxis === 'y' ? 'height' : 'width';\n\n    var _min = _offset + overflow[_mainSide];\n\n    var _max = _offset - overflow[_altSide];\n\n    var isOriginSide = [enums_top, left].indexOf(basePlacement) !== -1;\n\n    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\n\n    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\n\n    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\n\n    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\n\n    popperOffsets[altAxis] = _preventedOffset;\n    data[altAxis] = _preventedOffset - _offset;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const modifiers_preventOverflow = ({\n  name: 'preventOverflow',\n  enabled: true,\n  phase: 'main',\n  fn: preventOverflow,\n  requiresIfExists: ['offset']\n});\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/index.js\n\n\n\n\n\n\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js\nfunction getHTMLElementScroll(element) {\n  return {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js\n\n\n\n\nfunction getNodeScroll(node) {\n  if (node === getWindow(node) || !isHTMLElement(node)) {\n    return getWindowScroll(node);\n  } else {\n    return getHTMLElementScroll(node);\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js\n\n\n\n\n\n\n\n\n\nfunction isElementScaled(element) {\n  var rect = element.getBoundingClientRect();\n  var scaleX = round(rect.width) / element.offsetWidth || 1;\n  var scaleY = round(rect.height) / element.offsetHeight || 1;\n  return scaleX !== 1 || scaleY !== 1;\n} // Returns the composite rect of an element relative to its offsetParent.\n// Composite means it takes into account transforms as well as layout.\n\n\nfunction getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n\n  var isOffsetParentAnElement = isHTMLElement(offsetParent);\n  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);\n  var documentElement = getDocumentElement(offsetParent);\n  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);\n  var scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  var offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078\n    isScrollParent(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      offsets = getBoundingClientRect(offsetParent, true);\n      offsets.x += offsetParent.clientLeft;\n      offsets.y += offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/orderModifiers.js\n // source: https://stackoverflow.com/questions/49875255\n\nfunction order(modifiers) {\n  var map = new Map();\n  var visited = new Set();\n  var result = [];\n  modifiers.forEach(function (modifier) {\n    map.set(modifier.name, modifier);\n  }); // On visiting object, check for its dependencies and visit them recursively\n\n  function sort(modifier) {\n    visited.add(modifier.name);\n    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n    requires.forEach(function (dep) {\n      if (!visited.has(dep)) {\n        var depModifier = map.get(dep);\n\n        if (depModifier) {\n          sort(depModifier);\n        }\n      }\n    });\n    result.push(modifier);\n  }\n\n  modifiers.forEach(function (modifier) {\n    if (!visited.has(modifier.name)) {\n      // check for visited object\n      sort(modifier);\n    }\n  });\n  return result;\n}\n\nfunction orderModifiers(modifiers) {\n  // order based on dependencies\n  var orderedModifiers = order(modifiers); // order based on phase\n\n  return modifierPhases.reduce(function (acc, phase) {\n    return acc.concat(orderedModifiers.filter(function (modifier) {\n      return modifier.phase === phase;\n    }));\n  }, []);\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/debounce.js\nfunction debounce(fn) {\n  var pending;\n  return function () {\n    if (!pending) {\n      pending = new Promise(function (resolve) {\n        Promise.resolve().then(function () {\n          pending = undefined;\n          resolve(fn());\n        });\n      });\n    }\n\n    return pending;\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/mergeByName.js\nfunction mergeByName(modifiers) {\n  var merged = modifiers.reduce(function (merged, current) {\n    var existing = merged[current.name];\n    merged[current.name] = existing ? Object.assign({}, existing, current, {\n      options: Object.assign({}, existing.options, current.options),\n      data: Object.assign({}, existing.data, current.data)\n    }) : current;\n    return merged;\n  }, {}); // IE11 does not support Object.values\n\n  return Object.keys(merged).map(function (key) {\n    return merged[key];\n  });\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/createPopper.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';\nvar INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';\nvar DEFAULT_OPTIONS = {\n  placement: 'bottom',\n  modifiers: [],\n  strategy: 'absolute'\n};\n\nfunction areValidElements() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return !args.some(function (element) {\n    return !(element && typeof element.getBoundingClientRect === 'function');\n  });\n}\n\nfunction popperGenerator(generatorOptions) {\n  if (generatorOptions === void 0) {\n    generatorOptions = {};\n  }\n\n  var _generatorOptions = generatorOptions,\n      _generatorOptions$def = _generatorOptions.defaultModifiers,\n      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n      _generatorOptions$def2 = _generatorOptions.defaultOptions,\n      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n  return function createPopper(reference, popper, options) {\n    if (options === void 0) {\n      options = defaultOptions;\n    }\n\n    var state = {\n      placement: 'bottom',\n      orderedModifiers: [],\n      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n      modifiersData: {},\n      elements: {\n        reference: reference,\n        popper: popper\n      },\n      attributes: {},\n      styles: {}\n    };\n    var effectCleanupFns = [];\n    var isDestroyed = false;\n    var instance = {\n      state: state,\n      setOptions: function setOptions(setOptionsAction) {\n        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;\n        cleanupModifierEffects();\n        state.options = Object.assign({}, defaultOptions, state.options, options);\n        state.scrollParents = {\n          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n          popper: listScrollParents(popper)\n        }; // Orders the modifiers based on their dependencies and `phase`\n        // properties\n\n        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n        state.orderedModifiers = orderedModifiers.filter(function (m) {\n          return m.enabled;\n        }); // Validate the provided modifiers so that the consumer will get warned\n        // if one of the modifiers is invalid for any reason\n\n        if (false) { var _getComputedStyle, marginTop, marginRight, marginBottom, marginLeft, flipModifier, modifiers; }\n\n        runModifierEffects();\n        return instance.update();\n      },\n      // Sync update â€“ it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n\n        var _state$elements = state.elements,\n            reference = _state$elements.reference,\n            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n        // anymore\n\n        if (!areValidElements(reference, popper)) {\n          if (false) {}\n\n          return;\n        } // Store the reference and popper rects to be read by modifiers\n\n\n        state.rects = {\n          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n          popper: getLayoutRect(popper)\n        }; // Modifiers have the ability to reset the current update cycle. The\n        // most common use case for this is the `flip` modifier changing the\n        // placement, which then needs to re-run all the modifiers, because the\n        // logic was previously ran for the previous placement and is therefore\n        // stale/incorrect\n\n        state.reset = false;\n        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n        // is filled with the initial data specified by the modifier. This means\n        // it doesn't persist and is fresh on each update.\n        // To ensure persistent data, use `${name}#persistent`\n\n        state.orderedModifiers.forEach(function (modifier) {\n          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n        });\n        var __debug_loops__ = 0;\n\n        for (var index = 0; index < state.orderedModifiers.length; index++) {\n          if (false) {}\n\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n\n          var _state$orderedModifie = state.orderedModifiers[index],\n              fn = _state$orderedModifie.fn,\n              _state$orderedModifie2 = _state$orderedModifie.options,\n              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n              name = _state$orderedModifie.name;\n\n          if (typeof fn === 'function') {\n            state = fn({\n              state: state,\n              options: _options,\n              name: name,\n              instance: instance\n            }) || state;\n          }\n        }\n      },\n      // Async and optimistically optimized update â€“ it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: debounce(function () {\n        return new Promise(function (resolve) {\n          instance.forceUpdate();\n          resolve(state);\n        });\n      }),\n      destroy: function destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n\n    if (!areValidElements(reference, popper)) {\n      if (false) {}\n\n      return instance;\n    }\n\n    instance.setOptions(options).then(function (state) {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state);\n      }\n    }); // Modifiers have the ability to execute arbitrary code before the first\n    // update cycle runs. They will be executed in the same order as the update\n    // cycle. This is useful when a modifier adds some persistent data that\n    // other modifiers need to use, but the modifier is run after the dependent\n    // one.\n\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(function (_ref3) {\n        var name = _ref3.name,\n            _ref3$options = _ref3.options,\n            options = _ref3$options === void 0 ? {} : _ref3$options,\n            effect = _ref3.effect;\n\n        if (typeof effect === 'function') {\n          var cleanupFn = effect({\n            state: state,\n            name: name,\n            instance: instance,\n            options: options\n          });\n\n          var noopFn = function noopFn() {};\n\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(function (fn) {\n        return fn();\n      });\n      effectCleanupFns = [];\n    }\n\n    return instance;\n  };\n}\nvar createPopper = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules\n\n\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/popper.js\n\n\n\n\n\n\n\n\n\n\nvar defaultModifiers = [eventListeners, modifiers_popperOffsets, modifiers_computeStyles, modifiers_applyStyles, modifiers_offset, modifiers_flip, modifiers_preventOverflow, modifiers_arrow, modifiers_hide];\nvar popper_createPopper = /*#__PURE__*/popperGenerator({\n  defaultModifiers: defaultModifiers\n}); // eslint-disable-next-line import/no-unused-modules\n\n // eslint-disable-next-line import/no-unused-modules\n\n // eslint-disable-next-line import/no-unused-modules\n\n\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/popper-lite.js\n\n\n\n\n\nvar popper_lite_defaultModifiers = [eventListeners, modifiers_popperOffsets, modifiers_computeStyles, modifiers_applyStyles];\nvar popper_lite_createPopper = /*#__PURE__*/popperGenerator({\n  defaultModifiers: popper_lite_defaultModifiers\n}); // eslint-disable-next-line import/no-unused-modules\n\n\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/index.js\n\n // eslint-disable-next-line import/no-unused-modules\n\n // eslint-disable-next-line import/no-unused-modules\n\n // eslint-disable-next-line import/no-unused-modules\n\n\n\n/***/ }),\n\n/***/ 708:\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_69133__) => {\n\n__nested_webpack_require_69133__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n/***/ }),\n\n/***/ 931:\n/***/ ((__unused_webpack_module, __webpack_exports__, __nested_webpack_require_69322__) => {\n\n// ESM COMPAT FLAG\n__nested_webpack_require_69322__.r(__webpack_exports__);\n\n// EXPORTS\n__nested_webpack_require_69322__.d(__webpack_exports__, {\n  \"Application\": () => (/* reexport */ Application),\n  \"Context\": () => (/* reexport */ Context),\n  \"Controller\": () => (/* reexport */ Controller),\n  \"defaultSchema\": () => (/* reexport */ defaultSchema)\n});\n\n;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/event_listener.js\nvar EventListener = /** @class */ (function () {\n    function EventListener(eventTarget, eventName, eventOptions) {\n        this.eventTarget = eventTarget;\n        this.eventName = eventName;\n        this.eventOptions = eventOptions;\n        this.unorderedBindings = new Set();\n    }\n    EventListener.prototype.connect = function () {\n        this.eventTarget.addEventListener(this.eventName, this, this.eventOptions);\n    };\n    EventListener.prototype.disconnect = function () {\n        this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions);\n    };\n    // Binding observer delegate\n    /** @hidden */\n    EventListener.prototype.bindingConnected = function (binding) {\n        this.unorderedBindings.add(binding);\n    };\n    /** @hidden */\n    EventListener.prototype.bindingDisconnected = function (binding) {\n        this.unorderedBindings.delete(binding);\n    };\n    EventListener.prototype.handleEvent = function (event) {\n        var extendedEvent = extendEvent(event);\n        for (var _i = 0, _a = this.bindings; _i < _a.length; _i++) {\n            var binding = _a[_i];\n            if (extendedEvent.immediatePropagationStopped) {\n                break;\n            }\n            else {\n                binding.handleEvent(extendedEvent);\n            }\n        }\n    };\n    Object.defineProperty(EventListener.prototype, \"bindings\", {\n        get: function () {\n            return Array.from(this.unorderedBindings).sort(function (left, right) {\n                var leftIndex = left.index, rightIndex = right.index;\n                return leftIndex < rightIndex ? -1 : leftIndex > rightIndex ? 1 : 0;\n            });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return EventListener;\n}());\n\nfunction extendEvent(event) {\n    if (\"immediatePropagationStopped\" in event) {\n        return event;\n    }\n    else {\n        var stopImmediatePropagation_1 = event.stopImmediatePropagation;\n        return Object.assign(event, {\n            immediatePropagationStopped: false,\n            stopImmediatePropagation: function () {\n                this.immediatePropagationStopped = true;\n                stopImmediatePropagation_1.call(this);\n            }\n        });\n    }\n}\n//# sourceMappingURL=event_listener.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/dispatcher.js\n\nvar Dispatcher = /** @class */ (function () {\n    function Dispatcher(application) {\n        this.application = application;\n        this.eventListenerMaps = new Map;\n        this.started = false;\n    }\n    Dispatcher.prototype.start = function () {\n        if (!this.started) {\n            this.started = true;\n            this.eventListeners.forEach(function (eventListener) { return eventListener.connect(); });\n        }\n    };\n    Dispatcher.prototype.stop = function () {\n        if (this.started) {\n            this.started = false;\n            this.eventListeners.forEach(function (eventListener) { return eventListener.disconnect(); });\n        }\n    };\n    Object.defineProperty(Dispatcher.prototype, \"eventListeners\", {\n        get: function () {\n            return Array.from(this.eventListenerMaps.values())\n                .reduce(function (listeners, map) { return listeners.concat(Array.from(map.values())); }, []);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    // Binding observer delegate\n    /** @hidden */\n    Dispatcher.prototype.bindingConnected = function (binding) {\n        this.fetchEventListenerForBinding(binding).bindingConnected(binding);\n    };\n    /** @hidden */\n    Dispatcher.prototype.bindingDisconnected = function (binding) {\n        this.fetchEventListenerForBinding(binding).bindingDisconnected(binding);\n    };\n    // Error handling\n    Dispatcher.prototype.handleError = function (error, message, detail) {\n        if (detail === void 0) { detail = {}; }\n        this.application.handleError(error, \"Error \" + message, detail);\n    };\n    Dispatcher.prototype.fetchEventListenerForBinding = function (binding) {\n        var eventTarget = binding.eventTarget, eventName = binding.eventName, eventOptions = binding.eventOptions;\n        return this.fetchEventListener(eventTarget, eventName, eventOptions);\n    };\n    Dispatcher.prototype.fetchEventListener = function (eventTarget, eventName, eventOptions) {\n        var eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);\n        var cacheKey = this.cacheKey(eventName, eventOptions);\n        var eventListener = eventListenerMap.get(cacheKey);\n        if (!eventListener) {\n            eventListener = this.createEventListener(eventTarget, eventName, eventOptions);\n            eventListenerMap.set(cacheKey, eventListener);\n        }\n        return eventListener;\n    };\n    Dispatcher.prototype.createEventListener = function (eventTarget, eventName, eventOptions) {\n        var eventListener = new EventListener(eventTarget, eventName, eventOptions);\n        if (this.started) {\n            eventListener.connect();\n        }\n        return eventListener;\n    };\n    Dispatcher.prototype.fetchEventListenerMapForEventTarget = function (eventTarget) {\n        var eventListenerMap = this.eventListenerMaps.get(eventTarget);\n        if (!eventListenerMap) {\n            eventListenerMap = new Map;\n            this.eventListenerMaps.set(eventTarget, eventListenerMap);\n        }\n        return eventListenerMap;\n    };\n    Dispatcher.prototype.cacheKey = function (eventName, eventOptions) {\n        var parts = [eventName];\n        Object.keys(eventOptions).sort().forEach(function (key) {\n            parts.push(\"\" + (eventOptions[key] ? \"\" : \"!\") + key);\n        });\n        return parts.join(\":\");\n    };\n    return Dispatcher;\n}());\n\n//# sourceMappingURL=dispatcher.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/action_descriptor.js\n// capture nos.:            12   23 4               43   1 5   56 7      768 9  98\nvar descriptorPattern = /^((.+?)(@(window|document))?->)?(.+?)(#([^:]+?))(:(.+))?$/;\nfunction parseActionDescriptorString(descriptorString) {\n    var source = descriptorString.trim();\n    var matches = source.match(descriptorPattern) || [];\n    return {\n        eventTarget: parseEventTarget(matches[4]),\n        eventName: matches[2],\n        eventOptions: matches[9] ? parseEventOptions(matches[9]) : {},\n        identifier: matches[5],\n        methodName: matches[7]\n    };\n}\nfunction parseEventTarget(eventTargetName) {\n    if (eventTargetName == \"window\") {\n        return window;\n    }\n    else if (eventTargetName == \"document\") {\n        return document;\n    }\n}\nfunction parseEventOptions(eventOptions) {\n    return eventOptions.split(\":\").reduce(function (options, token) {\n        var _a;\n        return Object.assign(options, (_a = {}, _a[token.replace(/^!/, \"\")] = !/^!/.test(token), _a));\n    }, {});\n}\nfunction stringifyEventTarget(eventTarget) {\n    if (eventTarget == window) {\n        return \"window\";\n    }\n    else if (eventTarget == document) {\n        return \"document\";\n    }\n}\n//# sourceMappingURL=action_descriptor.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/action.js\n\nvar Action = /** @class */ (function () {\n    function Action(element, index, descriptor) {\n        this.element = element;\n        this.index = index;\n        this.eventTarget = descriptor.eventTarget || element;\n        this.eventName = descriptor.eventName || getDefaultEventNameForElement(element) || error(\"missing event name\");\n        this.eventOptions = descriptor.eventOptions || {};\n        this.identifier = descriptor.identifier || error(\"missing identifier\");\n        this.methodName = descriptor.methodName || error(\"missing method name\");\n    }\n    Action.forToken = function (token) {\n        return new this(token.element, token.index, parseActionDescriptorString(token.content));\n    };\n    Action.prototype.toString = function () {\n        var eventNameSuffix = this.eventTargetName ? \"@\" + this.eventTargetName : \"\";\n        return \"\" + this.eventName + eventNameSuffix + \"->\" + this.identifier + \"#\" + this.methodName;\n    };\n    Object.defineProperty(Action.prototype, \"eventTargetName\", {\n        get: function () {\n            return stringifyEventTarget(this.eventTarget);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Action;\n}());\n\nvar defaultEventNames = {\n    \"a\": function (e) { return \"click\"; },\n    \"button\": function (e) { return \"click\"; },\n    \"form\": function (e) { return \"submit\"; },\n    \"input\": function (e) { return e.getAttribute(\"type\") == \"submit\" ? \"click\" : \"input\"; },\n    \"select\": function (e) { return \"change\"; },\n    \"textarea\": function (e) { return \"input\"; }\n};\nfunction getDefaultEventNameForElement(element) {\n    var tagName = element.tagName.toLowerCase();\n    if (tagName in defaultEventNames) {\n        return defaultEventNames[tagName](element);\n    }\n}\nfunction error(message) {\n    throw new Error(message);\n}\n//# sourceMappingURL=action.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/binding.js\nvar Binding = /** @class */ (function () {\n    function Binding(context, action) {\n        this.context = context;\n        this.action = action;\n    }\n    Object.defineProperty(Binding.prototype, \"index\", {\n        get: function () {\n            return this.action.index;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Binding.prototype, \"eventTarget\", {\n        get: function () {\n            return this.action.eventTarget;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Binding.prototype, \"eventOptions\", {\n        get: function () {\n            return this.action.eventOptions;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Binding.prototype, \"identifier\", {\n        get: function () {\n            return this.context.identifier;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Binding.prototype.handleEvent = function (event) {\n        if (this.willBeInvokedByEvent(event)) {\n            this.invokeWithEvent(event);\n        }\n    };\n    Object.defineProperty(Binding.prototype, \"eventName\", {\n        get: function () {\n            return this.action.eventName;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Binding.prototype, \"method\", {\n        get: function () {\n            var method = this.controller[this.methodName];\n            if (typeof method == \"function\") {\n                return method;\n            }\n            throw new Error(\"Action \\\"\" + this.action + \"\\\" references undefined method \\\"\" + this.methodName + \"\\\"\");\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Binding.prototype.invokeWithEvent = function (event) {\n        try {\n            this.method.call(this.controller, event);\n        }\n        catch (error) {\n            var _a = this, identifier = _a.identifier, controller = _a.controller, element = _a.element, index = _a.index;\n            var detail = { identifier: identifier, controller: controller, element: element, index: index, event: event };\n            this.context.handleError(error, \"invoking action \\\"\" + this.action + \"\\\"\", detail);\n        }\n    };\n    Binding.prototype.willBeInvokedByEvent = function (event) {\n        var eventTarget = event.target;\n        if (this.element === eventTarget) {\n            return true;\n        }\n        else if (eventTarget instanceof Element && this.element.contains(eventTarget)) {\n            return this.scope.containsElement(eventTarget);\n        }\n        else {\n            return this.scope.containsElement(this.action.element);\n        }\n    };\n    Object.defineProperty(Binding.prototype, \"controller\", {\n        get: function () {\n            return this.context.controller;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Binding.prototype, \"methodName\", {\n        get: function () {\n            return this.action.methodName;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Binding.prototype, \"element\", {\n        get: function () {\n            return this.scope.element;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Binding.prototype, \"scope\", {\n        get: function () {\n            return this.context.scope;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Binding;\n}());\n\n//# sourceMappingURL=binding.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/mutation-observers/dist/element_observer.js\nvar ElementObserver = /** @class */ (function () {\n    function ElementObserver(element, delegate) {\n        var _this = this;\n        this.element = element;\n        this.started = false;\n        this.delegate = delegate;\n        this.elements = new Set;\n        this.mutationObserver = new MutationObserver(function (mutations) { return _this.processMutations(mutations); });\n    }\n    ElementObserver.prototype.start = function () {\n        if (!this.started) {\n            this.started = true;\n            this.mutationObserver.observe(this.element, { attributes: true, childList: true, subtree: true });\n            this.refresh();\n        }\n    };\n    ElementObserver.prototype.stop = function () {\n        if (this.started) {\n            this.mutationObserver.takeRecords();\n            this.mutationObserver.disconnect();\n            this.started = false;\n        }\n    };\n    ElementObserver.prototype.refresh = function () {\n        if (this.started) {\n            var matches = new Set(this.matchElementsInTree());\n            for (var _i = 0, _a = Array.from(this.elements); _i < _a.length; _i++) {\n                var element = _a[_i];\n                if (!matches.has(element)) {\n                    this.removeElement(element);\n                }\n            }\n            for (var _b = 0, _c = Array.from(matches); _b < _c.length; _b++) {\n                var element = _c[_b];\n                this.addElement(element);\n            }\n        }\n    };\n    // Mutation record processing\n    ElementObserver.prototype.processMutations = function (mutations) {\n        if (this.started) {\n            for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {\n                var mutation = mutations_1[_i];\n                this.processMutation(mutation);\n            }\n        }\n    };\n    ElementObserver.prototype.processMutation = function (mutation) {\n        if (mutation.type == \"attributes\") {\n            this.processAttributeChange(mutation.target, mutation.attributeName);\n        }\n        else if (mutation.type == \"childList\") {\n            this.processRemovedNodes(mutation.removedNodes);\n            this.processAddedNodes(mutation.addedNodes);\n        }\n    };\n    ElementObserver.prototype.processAttributeChange = function (node, attributeName) {\n        var element = node;\n        if (this.elements.has(element)) {\n            if (this.delegate.elementAttributeChanged && this.matchElement(element)) {\n                this.delegate.elementAttributeChanged(element, attributeName);\n            }\n            else {\n                this.removeElement(element);\n            }\n        }\n        else if (this.matchElement(element)) {\n            this.addElement(element);\n        }\n    };\n    ElementObserver.prototype.processRemovedNodes = function (nodes) {\n        for (var _i = 0, _a = Array.from(nodes); _i < _a.length; _i++) {\n            var node = _a[_i];\n            var element = this.elementFromNode(node);\n            if (element) {\n                this.processTree(element, this.removeElement);\n            }\n        }\n    };\n    ElementObserver.prototype.processAddedNodes = function (nodes) {\n        for (var _i = 0, _a = Array.from(nodes); _i < _a.length; _i++) {\n            var node = _a[_i];\n            var element = this.elementFromNode(node);\n            if (element && this.elementIsActive(element)) {\n                this.processTree(element, this.addElement);\n            }\n        }\n    };\n    // Element matching\n    ElementObserver.prototype.matchElement = function (element) {\n        return this.delegate.matchElement(element);\n    };\n    ElementObserver.prototype.matchElementsInTree = function (tree) {\n        if (tree === void 0) { tree = this.element; }\n        return this.delegate.matchElementsInTree(tree);\n    };\n    ElementObserver.prototype.processTree = function (tree, processor) {\n        for (var _i = 0, _a = this.matchElementsInTree(tree); _i < _a.length; _i++) {\n            var element = _a[_i];\n            processor.call(this, element);\n        }\n    };\n    ElementObserver.prototype.elementFromNode = function (node) {\n        if (node.nodeType == Node.ELEMENT_NODE) {\n            return node;\n        }\n    };\n    ElementObserver.prototype.elementIsActive = function (element) {\n        if (element.isConnected != this.element.isConnected) {\n            return false;\n        }\n        else {\n            return this.element.contains(element);\n        }\n    };\n    // Element tracking\n    ElementObserver.prototype.addElement = function (element) {\n        if (!this.elements.has(element)) {\n            if (this.elementIsActive(element)) {\n                this.elements.add(element);\n                if (this.delegate.elementMatched) {\n                    this.delegate.elementMatched(element);\n                }\n            }\n        }\n    };\n    ElementObserver.prototype.removeElement = function (element) {\n        if (this.elements.has(element)) {\n            this.elements.delete(element);\n            if (this.delegate.elementUnmatched) {\n                this.delegate.elementUnmatched(element);\n            }\n        }\n    };\n    return ElementObserver;\n}());\n\n//# sourceMappingURL=element_observer.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/mutation-observers/dist/attribute_observer.js\n\nvar AttributeObserver = /** @class */ (function () {\n    function AttributeObserver(element, attributeName, delegate) {\n        this.attributeName = attributeName;\n        this.delegate = delegate;\n        this.elementObserver = new ElementObserver(element, this);\n    }\n    Object.defineProperty(AttributeObserver.prototype, \"element\", {\n        get: function () {\n            return this.elementObserver.element;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AttributeObserver.prototype, \"selector\", {\n        get: function () {\n            return \"[\" + this.attributeName + \"]\";\n        },\n        enumerable: false,\n        configurable: true\n    });\n    AttributeObserver.prototype.start = function () {\n        this.elementObserver.start();\n    };\n    AttributeObserver.prototype.stop = function () {\n        this.elementObserver.stop();\n    };\n    AttributeObserver.prototype.refresh = function () {\n        this.elementObserver.refresh();\n    };\n    Object.defineProperty(AttributeObserver.prototype, \"started\", {\n        get: function () {\n            return this.elementObserver.started;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    // Element observer delegate\n    AttributeObserver.prototype.matchElement = function (element) {\n        return element.hasAttribute(this.attributeName);\n    };\n    AttributeObserver.prototype.matchElementsInTree = function (tree) {\n        var match = this.matchElement(tree) ? [tree] : [];\n        var matches = Array.from(tree.querySelectorAll(this.selector));\n        return match.concat(matches);\n    };\n    AttributeObserver.prototype.elementMatched = function (element) {\n        if (this.delegate.elementMatchedAttribute) {\n            this.delegate.elementMatchedAttribute(element, this.attributeName);\n        }\n    };\n    AttributeObserver.prototype.elementUnmatched = function (element) {\n        if (this.delegate.elementUnmatchedAttribute) {\n            this.delegate.elementUnmatchedAttribute(element, this.attributeName);\n        }\n    };\n    AttributeObserver.prototype.elementAttributeChanged = function (element, attributeName) {\n        if (this.delegate.elementAttributeValueChanged && this.attributeName == attributeName) {\n            this.delegate.elementAttributeValueChanged(element, attributeName);\n        }\n    };\n    return AttributeObserver;\n}());\n\n//# sourceMappingURL=attribute_observer.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/mutation-observers/dist/string_map_observer.js\nvar StringMapObserver = /** @class */ (function () {\n    function StringMapObserver(element, delegate) {\n        var _this = this;\n        this.element = element;\n        this.delegate = delegate;\n        this.started = false;\n        this.stringMap = new Map;\n        this.mutationObserver = new MutationObserver(function (mutations) { return _this.processMutations(mutations); });\n    }\n    StringMapObserver.prototype.start = function () {\n        if (!this.started) {\n            this.started = true;\n            this.mutationObserver.observe(this.element, { attributes: true });\n            this.refresh();\n        }\n    };\n    StringMapObserver.prototype.stop = function () {\n        if (this.started) {\n            this.mutationObserver.takeRecords();\n            this.mutationObserver.disconnect();\n            this.started = false;\n        }\n    };\n    StringMapObserver.prototype.refresh = function () {\n        if (this.started) {\n            for (var _i = 0, _a = this.knownAttributeNames; _i < _a.length; _i++) {\n                var attributeName = _a[_i];\n                this.refreshAttribute(attributeName);\n            }\n        }\n    };\n    // Mutation record processing\n    StringMapObserver.prototype.processMutations = function (mutations) {\n        if (this.started) {\n            for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {\n                var mutation = mutations_1[_i];\n                this.processMutation(mutation);\n            }\n        }\n    };\n    StringMapObserver.prototype.processMutation = function (mutation) {\n        var attributeName = mutation.attributeName;\n        if (attributeName) {\n            this.refreshAttribute(attributeName);\n        }\n    };\n    // State tracking\n    StringMapObserver.prototype.refreshAttribute = function (attributeName) {\n        var key = this.delegate.getStringMapKeyForAttribute(attributeName);\n        if (key != null) {\n            if (!this.stringMap.has(attributeName)) {\n                this.stringMapKeyAdded(key, attributeName);\n            }\n            var value = this.element.getAttribute(attributeName);\n            if (this.stringMap.get(attributeName) != value) {\n                this.stringMapValueChanged(value, key);\n            }\n            if (value == null) {\n                this.stringMap.delete(attributeName);\n                this.stringMapKeyRemoved(key, attributeName);\n            }\n            else {\n                this.stringMap.set(attributeName, value);\n            }\n        }\n    };\n    StringMapObserver.prototype.stringMapKeyAdded = function (key, attributeName) {\n        if (this.delegate.stringMapKeyAdded) {\n            this.delegate.stringMapKeyAdded(key, attributeName);\n        }\n    };\n    StringMapObserver.prototype.stringMapValueChanged = function (value, key) {\n        if (this.delegate.stringMapValueChanged) {\n            this.delegate.stringMapValueChanged(value, key);\n        }\n    };\n    StringMapObserver.prototype.stringMapKeyRemoved = function (key, attributeName) {\n        if (this.delegate.stringMapKeyRemoved) {\n            this.delegate.stringMapKeyRemoved(key, attributeName);\n        }\n    };\n    Object.defineProperty(StringMapObserver.prototype, \"knownAttributeNames\", {\n        get: function () {\n            return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)));\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(StringMapObserver.prototype, \"currentAttributeNames\", {\n        get: function () {\n            return Array.from(this.element.attributes).map(function (attribute) { return attribute.name; });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(StringMapObserver.prototype, \"recordedAttributeNames\", {\n        get: function () {\n            return Array.from(this.stringMap.keys());\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return StringMapObserver;\n}());\n\n//# sourceMappingURL=string_map_observer.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/multimap/dist/set_operations.js\nfunction add(map, key, value) {\n    fetch(map, key).add(value);\n}\nfunction del(map, key, value) {\n    fetch(map, key).delete(value);\n    prune(map, key);\n}\nfunction fetch(map, key) {\n    var values = map.get(key);\n    if (!values) {\n        values = new Set();\n        map.set(key, values);\n    }\n    return values;\n}\nfunction prune(map, key) {\n    var values = map.get(key);\n    if (values != null && values.size == 0) {\n        map.delete(key);\n    }\n}\n//# sourceMappingURL=set_operations.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/multimap/dist/multimap.js\n\nvar Multimap = /** @class */ (function () {\n    function Multimap() {\n        this.valuesByKey = new Map();\n    }\n    Object.defineProperty(Multimap.prototype, \"values\", {\n        get: function () {\n            var sets = Array.from(this.valuesByKey.values());\n            return sets.reduce(function (values, set) { return values.concat(Array.from(set)); }, []);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Multimap.prototype, \"size\", {\n        get: function () {\n            var sets = Array.from(this.valuesByKey.values());\n            return sets.reduce(function (size, set) { return size + set.size; }, 0);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Multimap.prototype.add = function (key, value) {\n        add(this.valuesByKey, key, value);\n    };\n    Multimap.prototype.delete = function (key, value) {\n        del(this.valuesByKey, key, value);\n    };\n    Multimap.prototype.has = function (key, value) {\n        var values = this.valuesByKey.get(key);\n        return values != null && values.has(value);\n    };\n    Multimap.prototype.hasKey = function (key) {\n        return this.valuesByKey.has(key);\n    };\n    Multimap.prototype.hasValue = function (value) {\n        var sets = Array.from(this.valuesByKey.values());\n        return sets.some(function (set) { return set.has(value); });\n    };\n    Multimap.prototype.getValuesForKey = function (key) {\n        var values = this.valuesByKey.get(key);\n        return values ? Array.from(values) : [];\n    };\n    Multimap.prototype.getKeysForValue = function (value) {\n        return Array.from(this.valuesByKey)\n            .filter(function (_a) {\n            var key = _a[0], values = _a[1];\n            return values.has(value);\n        })\n            .map(function (_a) {\n            var key = _a[0], values = _a[1];\n            return key;\n        });\n    };\n    return Multimap;\n}());\n\n//# sourceMappingURL=multimap.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/multimap/dist/indexed_multimap.js\nvar __extends = ( false) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\nvar IndexedMultimap = /** @class */ (function (_super) {\n    __extends(IndexedMultimap, _super);\n    function IndexedMultimap() {\n        var _this = _super.call(this) || this;\n        _this.keysByValue = new Map;\n        return _this;\n    }\n    Object.defineProperty(IndexedMultimap.prototype, \"values\", {\n        get: function () {\n            return Array.from(this.keysByValue.keys());\n        },\n        enumerable: false,\n        configurable: true\n    });\n    IndexedMultimap.prototype.add = function (key, value) {\n        _super.prototype.add.call(this, key, value);\n        add(this.keysByValue, value, key);\n    };\n    IndexedMultimap.prototype.delete = function (key, value) {\n        _super.prototype.delete.call(this, key, value);\n        del(this.keysByValue, value, key);\n    };\n    IndexedMultimap.prototype.hasValue = function (value) {\n        return this.keysByValue.has(value);\n    };\n    IndexedMultimap.prototype.getKeysForValue = function (value) {\n        var set = this.keysByValue.get(value);\n        return set ? Array.from(set) : [];\n    };\n    return IndexedMultimap;\n}(Multimap));\n\n//# sourceMappingURL=indexed_multimap.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/multimap/dist/index.js\n\n\n\n//# sourceMappingURL=index.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/mutation-observers/dist/token_list_observer.js\n\n\nvar TokenListObserver = /** @class */ (function () {\n    function TokenListObserver(element, attributeName, delegate) {\n        this.attributeObserver = new AttributeObserver(element, attributeName, this);\n        this.delegate = delegate;\n        this.tokensByElement = new Multimap;\n    }\n    Object.defineProperty(TokenListObserver.prototype, \"started\", {\n        get: function () {\n            return this.attributeObserver.started;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    TokenListObserver.prototype.start = function () {\n        this.attributeObserver.start();\n    };\n    TokenListObserver.prototype.stop = function () {\n        this.attributeObserver.stop();\n    };\n    TokenListObserver.prototype.refresh = function () {\n        this.attributeObserver.refresh();\n    };\n    Object.defineProperty(TokenListObserver.prototype, \"element\", {\n        get: function () {\n            return this.attributeObserver.element;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TokenListObserver.prototype, \"attributeName\", {\n        get: function () {\n            return this.attributeObserver.attributeName;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    // Attribute observer delegate\n    TokenListObserver.prototype.elementMatchedAttribute = function (element) {\n        this.tokensMatched(this.readTokensForElement(element));\n    };\n    TokenListObserver.prototype.elementAttributeValueChanged = function (element) {\n        var _a = this.refreshTokensForElement(element), unmatchedTokens = _a[0], matchedTokens = _a[1];\n        this.tokensUnmatched(unmatchedTokens);\n        this.tokensMatched(matchedTokens);\n    };\n    TokenListObserver.prototype.elementUnmatchedAttribute = function (element) {\n        this.tokensUnmatched(this.tokensByElement.getValuesForKey(element));\n    };\n    TokenListObserver.prototype.tokensMatched = function (tokens) {\n        var _this = this;\n        tokens.forEach(function (token) { return _this.tokenMatched(token); });\n    };\n    TokenListObserver.prototype.tokensUnmatched = function (tokens) {\n        var _this = this;\n        tokens.forEach(function (token) { return _this.tokenUnmatched(token); });\n    };\n    TokenListObserver.prototype.tokenMatched = function (token) {\n        this.delegate.tokenMatched(token);\n        this.tokensByElement.add(token.element, token);\n    };\n    TokenListObserver.prototype.tokenUnmatched = function (token) {\n        this.delegate.tokenUnmatched(token);\n        this.tokensByElement.delete(token.element, token);\n    };\n    TokenListObserver.prototype.refreshTokensForElement = function (element) {\n        var previousTokens = this.tokensByElement.getValuesForKey(element);\n        var currentTokens = this.readTokensForElement(element);\n        var firstDifferingIndex = zip(previousTokens, currentTokens)\n            .findIndex(function (_a) {\n            var previousToken = _a[0], currentToken = _a[1];\n            return !tokensAreEqual(previousToken, currentToken);\n        });\n        if (firstDifferingIndex == -1) {\n            return [[], []];\n        }\n        else {\n            return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)];\n        }\n    };\n    TokenListObserver.prototype.readTokensForElement = function (element) {\n        var attributeName = this.attributeName;\n        var tokenString = element.getAttribute(attributeName) || \"\";\n        return parseTokenString(tokenString, element, attributeName);\n    };\n    return TokenListObserver;\n}());\n\nfunction parseTokenString(tokenString, element, attributeName) {\n    return tokenString.trim().split(/\\s+/).filter(function (content) { return content.length; })\n        .map(function (content, index) { return ({ element: element, attributeName: attributeName, content: content, index: index }); });\n}\nfunction zip(left, right) {\n    var length = Math.max(left.length, right.length);\n    return Array.from({ length: length }, function (_, index) { return [left[index], right[index]]; });\n}\nfunction tokensAreEqual(left, right) {\n    return left && right && left.index == right.index && left.content == right.content;\n}\n//# sourceMappingURL=token_list_observer.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/mutation-observers/dist/value_list_observer.js\n\nvar ValueListObserver = /** @class */ (function () {\n    function ValueListObserver(element, attributeName, delegate) {\n        this.tokenListObserver = new TokenListObserver(element, attributeName, this);\n        this.delegate = delegate;\n        this.parseResultsByToken = new WeakMap;\n        this.valuesByTokenByElement = new WeakMap;\n    }\n    Object.defineProperty(ValueListObserver.prototype, \"started\", {\n        get: function () {\n            return this.tokenListObserver.started;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ValueListObserver.prototype.start = function () {\n        this.tokenListObserver.start();\n    };\n    ValueListObserver.prototype.stop = function () {\n        this.tokenListObserver.stop();\n    };\n    ValueListObserver.prototype.refresh = function () {\n        this.tokenListObserver.refresh();\n    };\n    Object.defineProperty(ValueListObserver.prototype, \"element\", {\n        get: function () {\n            return this.tokenListObserver.element;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ValueListObserver.prototype, \"attributeName\", {\n        get: function () {\n            return this.tokenListObserver.attributeName;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ValueListObserver.prototype.tokenMatched = function (token) {\n        var element = token.element;\n        var value = this.fetchParseResultForToken(token).value;\n        if (value) {\n            this.fetchValuesByTokenForElement(element).set(token, value);\n            this.delegate.elementMatchedValue(element, value);\n        }\n    };\n    ValueListObserver.prototype.tokenUnmatched = function (token) {\n        var element = token.element;\n        var value = this.fetchParseResultForToken(token).value;\n        if (value) {\n            this.fetchValuesByTokenForElement(element).delete(token);\n            this.delegate.elementUnmatchedValue(element, value);\n        }\n    };\n    ValueListObserver.prototype.fetchParseResultForToken = function (token) {\n        var parseResult = this.parseResultsByToken.get(token);\n        if (!parseResult) {\n            parseResult = this.parseToken(token);\n            this.parseResultsByToken.set(token, parseResult);\n        }\n        return parseResult;\n    };\n    ValueListObserver.prototype.fetchValuesByTokenForElement = function (element) {\n        var valuesByToken = this.valuesByTokenByElement.get(element);\n        if (!valuesByToken) {\n            valuesByToken = new Map;\n            this.valuesByTokenByElement.set(element, valuesByToken);\n        }\n        return valuesByToken;\n    };\n    ValueListObserver.prototype.parseToken = function (token) {\n        try {\n            var value = this.delegate.parseValueForToken(token);\n            return { value: value };\n        }\n        catch (error) {\n            return { error: error };\n        }\n    };\n    return ValueListObserver;\n}());\n\n//# sourceMappingURL=value_list_observer.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/mutation-observers/dist/index.js\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/binding_observer.js\n\n\n\nvar BindingObserver = /** @class */ (function () {\n    function BindingObserver(context, delegate) {\n        this.context = context;\n        this.delegate = delegate;\n        this.bindingsByAction = new Map;\n    }\n    BindingObserver.prototype.start = function () {\n        if (!this.valueListObserver) {\n            this.valueListObserver = new ValueListObserver(this.element, this.actionAttribute, this);\n            this.valueListObserver.start();\n        }\n    };\n    BindingObserver.prototype.stop = function () {\n        if (this.valueListObserver) {\n            this.valueListObserver.stop();\n            delete this.valueListObserver;\n            this.disconnectAllActions();\n        }\n    };\n    Object.defineProperty(BindingObserver.prototype, \"element\", {\n        get: function () {\n            return this.context.element;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BindingObserver.prototype, \"identifier\", {\n        get: function () {\n            return this.context.identifier;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BindingObserver.prototype, \"actionAttribute\", {\n        get: function () {\n            return this.schema.actionAttribute;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BindingObserver.prototype, \"schema\", {\n        get: function () {\n            return this.context.schema;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BindingObserver.prototype, \"bindings\", {\n        get: function () {\n            return Array.from(this.bindingsByAction.values());\n        },\n        enumerable: false,\n        configurable: true\n    });\n    BindingObserver.prototype.connectAction = function (action) {\n        var binding = new Binding(this.context, action);\n        this.bindingsByAction.set(action, binding);\n        this.delegate.bindingConnected(binding);\n    };\n    BindingObserver.prototype.disconnectAction = function (action) {\n        var binding = this.bindingsByAction.get(action);\n        if (binding) {\n            this.bindingsByAction.delete(action);\n            this.delegate.bindingDisconnected(binding);\n        }\n    };\n    BindingObserver.prototype.disconnectAllActions = function () {\n        var _this = this;\n        this.bindings.forEach(function (binding) { return _this.delegate.bindingDisconnected(binding); });\n        this.bindingsByAction.clear();\n    };\n    // Value observer delegate\n    BindingObserver.prototype.parseValueForToken = function (token) {\n        var action = Action.forToken(token);\n        if (action.identifier == this.identifier) {\n            return action;\n        }\n    };\n    BindingObserver.prototype.elementMatchedValue = function (element, action) {\n        this.connectAction(action);\n    };\n    BindingObserver.prototype.elementUnmatchedValue = function (element, action) {\n        this.disconnectAction(action);\n    };\n    return BindingObserver;\n}());\n\n//# sourceMappingURL=binding_observer.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/value_observer.js\n\nvar ValueObserver = /** @class */ (function () {\n    function ValueObserver(context, receiver) {\n        this.context = context;\n        this.receiver = receiver;\n        this.stringMapObserver = new StringMapObserver(this.element, this);\n        this.valueDescriptorMap = this.controller.valueDescriptorMap;\n        this.invokeChangedCallbacksForDefaultValues();\n    }\n    ValueObserver.prototype.start = function () {\n        this.stringMapObserver.start();\n    };\n    ValueObserver.prototype.stop = function () {\n        this.stringMapObserver.stop();\n    };\n    Object.defineProperty(ValueObserver.prototype, \"element\", {\n        get: function () {\n            return this.context.element;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ValueObserver.prototype, \"controller\", {\n        get: function () {\n            return this.context.controller;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    // String map observer delegate\n    ValueObserver.prototype.getStringMapKeyForAttribute = function (attributeName) {\n        if (attributeName in this.valueDescriptorMap) {\n            return this.valueDescriptorMap[attributeName].name;\n        }\n    };\n    ValueObserver.prototype.stringMapValueChanged = function (attributeValue, name) {\n        this.invokeChangedCallbackForValue(name);\n    };\n    ValueObserver.prototype.invokeChangedCallbacksForDefaultValues = function () {\n        for (var _i = 0, _a = this.valueDescriptors; _i < _a.length; _i++) {\n            var _b = _a[_i], key = _b.key, name_1 = _b.name, defaultValue = _b.defaultValue;\n            if (defaultValue != undefined && !this.controller.data.has(key)) {\n                this.invokeChangedCallbackForValue(name_1);\n            }\n        }\n    };\n    ValueObserver.prototype.invokeChangedCallbackForValue = function (name) {\n        var methodName = name + \"Changed\";\n        var method = this.receiver[methodName];\n        if (typeof method == \"function\") {\n            var value = this.receiver[name];\n            method.call(this.receiver, value);\n        }\n    };\n    Object.defineProperty(ValueObserver.prototype, \"valueDescriptors\", {\n        get: function () {\n            var valueDescriptorMap = this.valueDescriptorMap;\n            return Object.keys(valueDescriptorMap).map(function (key) { return valueDescriptorMap[key]; });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return ValueObserver;\n}());\n\n//# sourceMappingURL=value_observer.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/context.js\n\n\nvar Context = /** @class */ (function () {\n    function Context(module, scope) {\n        this.module = module;\n        this.scope = scope;\n        this.controller = new module.controllerConstructor(this);\n        this.bindingObserver = new BindingObserver(this, this.dispatcher);\n        this.valueObserver = new ValueObserver(this, this.controller);\n        try {\n            this.controller.initialize();\n        }\n        catch (error) {\n            this.handleError(error, \"initializing controller\");\n        }\n    }\n    Context.prototype.connect = function () {\n        this.bindingObserver.start();\n        this.valueObserver.start();\n        try {\n            this.controller.connect();\n        }\n        catch (error) {\n            this.handleError(error, \"connecting controller\");\n        }\n    };\n    Context.prototype.disconnect = function () {\n        try {\n            this.controller.disconnect();\n        }\n        catch (error) {\n            this.handleError(error, \"disconnecting controller\");\n        }\n        this.valueObserver.stop();\n        this.bindingObserver.stop();\n    };\n    Object.defineProperty(Context.prototype, \"application\", {\n        get: function () {\n            return this.module.application;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Context.prototype, \"identifier\", {\n        get: function () {\n            return this.module.identifier;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Context.prototype, \"schema\", {\n        get: function () {\n            return this.application.schema;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Context.prototype, \"dispatcher\", {\n        get: function () {\n            return this.application.dispatcher;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Context.prototype, \"element\", {\n        get: function () {\n            return this.scope.element;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Context.prototype, \"parentElement\", {\n        get: function () {\n            return this.element.parentElement;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    // Error handling\n    Context.prototype.handleError = function (error, message, detail) {\n        if (detail === void 0) { detail = {}; }\n        var _a = this, identifier = _a.identifier, controller = _a.controller, element = _a.element;\n        detail = Object.assign({ identifier: identifier, controller: controller, element: element }, detail);\n        this.application.handleError(error, \"Error \" + message, detail);\n    };\n    return Context;\n}());\n\n//# sourceMappingURL=context.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/inheritable_statics.js\nfunction readInheritableStaticArrayValues(constructor, propertyName) {\n    var ancestors = getAncestorsForConstructor(constructor);\n    return Array.from(ancestors.reduce(function (values, constructor) {\n        getOwnStaticArrayValues(constructor, propertyName).forEach(function (name) { return values.add(name); });\n        return values;\n    }, new Set));\n}\nfunction readInheritableStaticObjectPairs(constructor, propertyName) {\n    var ancestors = getAncestorsForConstructor(constructor);\n    return ancestors.reduce(function (pairs, constructor) {\n        pairs.push.apply(pairs, getOwnStaticObjectPairs(constructor, propertyName));\n        return pairs;\n    }, []);\n}\nfunction getAncestorsForConstructor(constructor) {\n    var ancestors = [];\n    while (constructor) {\n        ancestors.push(constructor);\n        constructor = Object.getPrototypeOf(constructor);\n    }\n    return ancestors.reverse();\n}\nfunction getOwnStaticArrayValues(constructor, propertyName) {\n    var definition = constructor[propertyName];\n    return Array.isArray(definition) ? definition : [];\n}\nfunction getOwnStaticObjectPairs(constructor, propertyName) {\n    var definition = constructor[propertyName];\n    return definition ? Object.keys(definition).map(function (key) { return [key, definition[key]]; }) : [];\n}\n//# sourceMappingURL=inheritable_statics.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/blessing.js\nvar blessing_extends = ( false) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __spreadArrays = ( false) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\n\n/** @hidden */\nfunction bless(constructor) {\n    return shadow(constructor, getBlessedProperties(constructor));\n}\nfunction shadow(constructor, properties) {\n    var shadowConstructor = extend(constructor);\n    var shadowProperties = getShadowProperties(constructor.prototype, properties);\n    Object.defineProperties(shadowConstructor.prototype, shadowProperties);\n    return shadowConstructor;\n}\nfunction getBlessedProperties(constructor) {\n    var blessings = readInheritableStaticArrayValues(constructor, \"blessings\");\n    return blessings.reduce(function (blessedProperties, blessing) {\n        var properties = blessing(constructor);\n        for (var key in properties) {\n            var descriptor = blessedProperties[key] || {};\n            blessedProperties[key] = Object.assign(descriptor, properties[key]);\n        }\n        return blessedProperties;\n    }, {});\n}\nfunction getShadowProperties(prototype, properties) {\n    return getOwnKeys(properties).reduce(function (shadowProperties, key) {\n        var _a;\n        var descriptor = getShadowedDescriptor(prototype, properties, key);\n        if (descriptor) {\n            Object.assign(shadowProperties, (_a = {}, _a[key] = descriptor, _a));\n        }\n        return shadowProperties;\n    }, {});\n}\nfunction getShadowedDescriptor(prototype, properties, key) {\n    var shadowingDescriptor = Object.getOwnPropertyDescriptor(prototype, key);\n    var shadowedByValue = shadowingDescriptor && \"value\" in shadowingDescriptor;\n    if (!shadowedByValue) {\n        var descriptor = Object.getOwnPropertyDescriptor(properties, key).value;\n        if (shadowingDescriptor) {\n            descriptor.get = shadowingDescriptor.get || descriptor.get;\n            descriptor.set = shadowingDescriptor.set || descriptor.set;\n        }\n        return descriptor;\n    }\n}\nvar getOwnKeys = (function () {\n    if (typeof Object.getOwnPropertySymbols == \"function\") {\n        return function (object) { return __spreadArrays(Object.getOwnPropertyNames(object), Object.getOwnPropertySymbols(object)); };\n    }\n    else {\n        return Object.getOwnPropertyNames;\n    }\n})();\nvar extend = (function () {\n    function extendWithReflect(constructor) {\n        function extended() {\n            var _newTarget = this && this instanceof extended ? this.constructor : void 0;\n            return Reflect.construct(constructor, arguments, _newTarget);\n        }\n        extended.prototype = Object.create(constructor.prototype, {\n            constructor: { value: extended }\n        });\n        Reflect.setPrototypeOf(extended, constructor);\n        return extended;\n    }\n    function testReflectExtension() {\n        var a = function () { this.a.call(this); };\n        var b = extendWithReflect(a);\n        b.prototype.a = function () { };\n        return new b;\n    }\n    try {\n        testReflectExtension();\n        return extendWithReflect;\n    }\n    catch (error) {\n        return function (constructor) { return /** @class */ (function (_super) {\n            blessing_extends(extended, _super);\n            function extended() {\n                return _super !== null && _super.apply(this, arguments) || this;\n            }\n            return extended;\n        }(constructor)); };\n    }\n})();\n//# sourceMappingURL=blessing.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/definition.js\n\n/** @hidden */\nfunction blessDefinition(definition) {\n    return {\n        identifier: definition.identifier,\n        controllerConstructor: bless(definition.controllerConstructor)\n    };\n}\n//# sourceMappingURL=definition.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/module.js\n\n\nvar Module = /** @class */ (function () {\n    function Module(application, definition) {\n        this.application = application;\n        this.definition = blessDefinition(definition);\n        this.contextsByScope = new WeakMap;\n        this.connectedContexts = new Set;\n    }\n    Object.defineProperty(Module.prototype, \"identifier\", {\n        get: function () {\n            return this.definition.identifier;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Module.prototype, \"controllerConstructor\", {\n        get: function () {\n            return this.definition.controllerConstructor;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Module.prototype, \"contexts\", {\n        get: function () {\n            return Array.from(this.connectedContexts);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Module.prototype.connectContextForScope = function (scope) {\n        var context = this.fetchContextForScope(scope);\n        this.connectedContexts.add(context);\n        context.connect();\n    };\n    Module.prototype.disconnectContextForScope = function (scope) {\n        var context = this.contextsByScope.get(scope);\n        if (context) {\n            this.connectedContexts.delete(context);\n            context.disconnect();\n        }\n    };\n    Module.prototype.fetchContextForScope = function (scope) {\n        var context = this.contextsByScope.get(scope);\n        if (!context) {\n            context = new Context(this, scope);\n            this.contextsByScope.set(scope, context);\n        }\n        return context;\n    };\n    return Module;\n}());\n\n//# sourceMappingURL=module.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/class_map.js\nvar ClassMap = /** @class */ (function () {\n    function ClassMap(scope) {\n        this.scope = scope;\n    }\n    ClassMap.prototype.has = function (name) {\n        return this.data.has(this.getDataKey(name));\n    };\n    ClassMap.prototype.get = function (name) {\n        return this.data.get(this.getDataKey(name));\n    };\n    ClassMap.prototype.getAttributeName = function (name) {\n        return this.data.getAttributeNameForKey(this.getDataKey(name));\n    };\n    ClassMap.prototype.getDataKey = function (name) {\n        return name + \"-class\";\n    };\n    Object.defineProperty(ClassMap.prototype, \"data\", {\n        get: function () {\n            return this.scope.data;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return ClassMap;\n}());\n\n//# sourceMappingURL=class_map.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/string_helpers.js\nfunction camelize(value) {\n    return value.replace(/(?:[_-])([a-z0-9])/g, function (_, char) { return char.toUpperCase(); });\n}\nfunction capitalize(value) {\n    return value.charAt(0).toUpperCase() + value.slice(1);\n}\nfunction dasherize(value) {\n    return value.replace(/([A-Z])/g, function (_, char) { return \"-\" + char.toLowerCase(); });\n}\n//# sourceMappingURL=string_helpers.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/data_map.js\n\nvar DataMap = /** @class */ (function () {\n    function DataMap(scope) {\n        this.scope = scope;\n    }\n    Object.defineProperty(DataMap.prototype, \"element\", {\n        get: function () {\n            return this.scope.element;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(DataMap.prototype, \"identifier\", {\n        get: function () {\n            return this.scope.identifier;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    DataMap.prototype.get = function (key) {\n        var name = this.getAttributeNameForKey(key);\n        return this.element.getAttribute(name);\n    };\n    DataMap.prototype.set = function (key, value) {\n        var name = this.getAttributeNameForKey(key);\n        this.element.setAttribute(name, value);\n        return this.get(key);\n    };\n    DataMap.prototype.has = function (key) {\n        var name = this.getAttributeNameForKey(key);\n        return this.element.hasAttribute(name);\n    };\n    DataMap.prototype.delete = function (key) {\n        if (this.has(key)) {\n            var name_1 = this.getAttributeNameForKey(key);\n            this.element.removeAttribute(name_1);\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    DataMap.prototype.getAttributeNameForKey = function (key) {\n        return \"data-\" + this.identifier + \"-\" + dasherize(key);\n    };\n    return DataMap;\n}());\n\n//# sourceMappingURL=data_map.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/guide.js\nvar Guide = /** @class */ (function () {\n    function Guide(logger) {\n        this.warnedKeysByObject = new WeakMap;\n        this.logger = logger;\n    }\n    Guide.prototype.warn = function (object, key, message) {\n        var warnedKeys = this.warnedKeysByObject.get(object);\n        if (!warnedKeys) {\n            warnedKeys = new Set;\n            this.warnedKeysByObject.set(object, warnedKeys);\n        }\n        if (!warnedKeys.has(key)) {\n            warnedKeys.add(key);\n            this.logger.warn(message, object);\n        }\n    };\n    return Guide;\n}());\n\n//# sourceMappingURL=guide.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/selectors.js\n/** @hidden */\nfunction attributeValueContainsToken(attributeName, token) {\n    return \"[\" + attributeName + \"~=\\\"\" + token + \"\\\"]\";\n}\n//# sourceMappingURL=selectors.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/target_set.js\nvar target_set_spreadArrays = ( false) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\n\nvar TargetSet = /** @class */ (function () {\n    function TargetSet(scope) {\n        this.scope = scope;\n    }\n    Object.defineProperty(TargetSet.prototype, \"element\", {\n        get: function () {\n            return this.scope.element;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TargetSet.prototype, \"identifier\", {\n        get: function () {\n            return this.scope.identifier;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TargetSet.prototype, \"schema\", {\n        get: function () {\n            return this.scope.schema;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    TargetSet.prototype.has = function (targetName) {\n        return this.find(targetName) != null;\n    };\n    TargetSet.prototype.find = function () {\n        var _this = this;\n        var targetNames = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            targetNames[_i] = arguments[_i];\n        }\n        return targetNames.reduce(function (target, targetName) {\n            return target\n                || _this.findTarget(targetName)\n                || _this.findLegacyTarget(targetName);\n        }, undefined);\n    };\n    TargetSet.prototype.findAll = function () {\n        var _this = this;\n        var targetNames = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            targetNames[_i] = arguments[_i];\n        }\n        return targetNames.reduce(function (targets, targetName) { return target_set_spreadArrays(targets, _this.findAllTargets(targetName), _this.findAllLegacyTargets(targetName)); }, []);\n    };\n    TargetSet.prototype.findTarget = function (targetName) {\n        var selector = this.getSelectorForTargetName(targetName);\n        return this.scope.findElement(selector);\n    };\n    TargetSet.prototype.findAllTargets = function (targetName) {\n        var selector = this.getSelectorForTargetName(targetName);\n        return this.scope.findAllElements(selector);\n    };\n    TargetSet.prototype.getSelectorForTargetName = function (targetName) {\n        var attributeName = \"data-\" + this.identifier + \"-target\";\n        return attributeValueContainsToken(attributeName, targetName);\n    };\n    TargetSet.prototype.findLegacyTarget = function (targetName) {\n        var selector = this.getLegacySelectorForTargetName(targetName);\n        return this.deprecate(this.scope.findElement(selector), targetName);\n    };\n    TargetSet.prototype.findAllLegacyTargets = function (targetName) {\n        var _this = this;\n        var selector = this.getLegacySelectorForTargetName(targetName);\n        return this.scope.findAllElements(selector).map(function (element) { return _this.deprecate(element, targetName); });\n    };\n    TargetSet.prototype.getLegacySelectorForTargetName = function (targetName) {\n        var targetDescriptor = this.identifier + \".\" + targetName;\n        return attributeValueContainsToken(this.schema.targetAttribute, targetDescriptor);\n    };\n    TargetSet.prototype.deprecate = function (element, targetName) {\n        if (element) {\n            var identifier = this.identifier;\n            var attributeName = this.schema.targetAttribute;\n            this.guide.warn(element, \"target:\" + targetName, \"Please replace \" + attributeName + \"=\\\"\" + identifier + \".\" + targetName + \"\\\" with data-\" + identifier + \"-target=\\\"\" + targetName + \"\\\". \" +\n                (\"The \" + attributeName + \" attribute is deprecated and will be removed in a future version of Stimulus.\"));\n        }\n        return element;\n    };\n    Object.defineProperty(TargetSet.prototype, \"guide\", {\n        get: function () {\n            return this.scope.guide;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return TargetSet;\n}());\n\n//# sourceMappingURL=target_set.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/scope.js\nvar scope_spreadArrays = ( false) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\n\n\n\n\n\nvar Scope = /** @class */ (function () {\n    function Scope(schema, element, identifier, logger) {\n        var _this = this;\n        this.targets = new TargetSet(this);\n        this.classes = new ClassMap(this);\n        this.data = new DataMap(this);\n        this.containsElement = function (element) {\n            return element.closest(_this.controllerSelector) === _this.element;\n        };\n        this.schema = schema;\n        this.element = element;\n        this.identifier = identifier;\n        this.guide = new Guide(logger);\n    }\n    Scope.prototype.findElement = function (selector) {\n        return this.element.matches(selector)\n            ? this.element\n            : this.queryElements(selector).find(this.containsElement);\n    };\n    Scope.prototype.findAllElements = function (selector) {\n        return scope_spreadArrays(this.element.matches(selector) ? [this.element] : [], this.queryElements(selector).filter(this.containsElement));\n    };\n    Scope.prototype.queryElements = function (selector) {\n        return Array.from(this.element.querySelectorAll(selector));\n    };\n    Object.defineProperty(Scope.prototype, \"controllerSelector\", {\n        get: function () {\n            return attributeValueContainsToken(this.schema.controllerAttribute, this.identifier);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Scope;\n}());\n\n//# sourceMappingURL=scope.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/scope_observer.js\n\nvar ScopeObserver = /** @class */ (function () {\n    function ScopeObserver(element, schema, delegate) {\n        this.element = element;\n        this.schema = schema;\n        this.delegate = delegate;\n        this.valueListObserver = new ValueListObserver(this.element, this.controllerAttribute, this);\n        this.scopesByIdentifierByElement = new WeakMap;\n        this.scopeReferenceCounts = new WeakMap;\n    }\n    ScopeObserver.prototype.start = function () {\n        this.valueListObserver.start();\n    };\n    ScopeObserver.prototype.stop = function () {\n        this.valueListObserver.stop();\n    };\n    Object.defineProperty(ScopeObserver.prototype, \"controllerAttribute\", {\n        get: function () {\n            return this.schema.controllerAttribute;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    // Value observer delegate\n    /** @hidden */\n    ScopeObserver.prototype.parseValueForToken = function (token) {\n        var element = token.element, identifier = token.content;\n        var scopesByIdentifier = this.fetchScopesByIdentifierForElement(element);\n        var scope = scopesByIdentifier.get(identifier);\n        if (!scope) {\n            scope = this.delegate.createScopeForElementAndIdentifier(element, identifier);\n            scopesByIdentifier.set(identifier, scope);\n        }\n        return scope;\n    };\n    /** @hidden */\n    ScopeObserver.prototype.elementMatchedValue = function (element, value) {\n        var referenceCount = (this.scopeReferenceCounts.get(value) || 0) + 1;\n        this.scopeReferenceCounts.set(value, referenceCount);\n        if (referenceCount == 1) {\n            this.delegate.scopeConnected(value);\n        }\n    };\n    /** @hidden */\n    ScopeObserver.prototype.elementUnmatchedValue = function (element, value) {\n        var referenceCount = this.scopeReferenceCounts.get(value);\n        if (referenceCount) {\n            this.scopeReferenceCounts.set(value, referenceCount - 1);\n            if (referenceCount == 1) {\n                this.delegate.scopeDisconnected(value);\n            }\n        }\n    };\n    ScopeObserver.prototype.fetchScopesByIdentifierForElement = function (element) {\n        var scopesByIdentifier = this.scopesByIdentifierByElement.get(element);\n        if (!scopesByIdentifier) {\n            scopesByIdentifier = new Map;\n            this.scopesByIdentifierByElement.set(element, scopesByIdentifier);\n        }\n        return scopesByIdentifier;\n    };\n    return ScopeObserver;\n}());\n\n//# sourceMappingURL=scope_observer.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/router.js\n\n\n\n\nvar Router = /** @class */ (function () {\n    function Router(application) {\n        this.application = application;\n        this.scopeObserver = new ScopeObserver(this.element, this.schema, this);\n        this.scopesByIdentifier = new Multimap;\n        this.modulesByIdentifier = new Map;\n    }\n    Object.defineProperty(Router.prototype, \"element\", {\n        get: function () {\n            return this.application.element;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Router.prototype, \"schema\", {\n        get: function () {\n            return this.application.schema;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Router.prototype, \"logger\", {\n        get: function () {\n            return this.application.logger;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Router.prototype, \"controllerAttribute\", {\n        get: function () {\n            return this.schema.controllerAttribute;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Router.prototype, \"modules\", {\n        get: function () {\n            return Array.from(this.modulesByIdentifier.values());\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Router.prototype, \"contexts\", {\n        get: function () {\n            return this.modules.reduce(function (contexts, module) { return contexts.concat(module.contexts); }, []);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Router.prototype.start = function () {\n        this.scopeObserver.start();\n    };\n    Router.prototype.stop = function () {\n        this.scopeObserver.stop();\n    };\n    Router.prototype.loadDefinition = function (definition) {\n        this.unloadIdentifier(definition.identifier);\n        var module = new Module(this.application, definition);\n        this.connectModule(module);\n    };\n    Router.prototype.unloadIdentifier = function (identifier) {\n        var module = this.modulesByIdentifier.get(identifier);\n        if (module) {\n            this.disconnectModule(module);\n        }\n    };\n    Router.prototype.getContextForElementAndIdentifier = function (element, identifier) {\n        var module = this.modulesByIdentifier.get(identifier);\n        if (module) {\n            return module.contexts.find(function (context) { return context.element == element; });\n        }\n    };\n    // Error handler delegate\n    /** @hidden */\n    Router.prototype.handleError = function (error, message, detail) {\n        this.application.handleError(error, message, detail);\n    };\n    // Scope observer delegate\n    /** @hidden */\n    Router.prototype.createScopeForElementAndIdentifier = function (element, identifier) {\n        return new Scope(this.schema, element, identifier, this.logger);\n    };\n    /** @hidden */\n    Router.prototype.scopeConnected = function (scope) {\n        this.scopesByIdentifier.add(scope.identifier, scope);\n        var module = this.modulesByIdentifier.get(scope.identifier);\n        if (module) {\n            module.connectContextForScope(scope);\n        }\n    };\n    /** @hidden */\n    Router.prototype.scopeDisconnected = function (scope) {\n        this.scopesByIdentifier.delete(scope.identifier, scope);\n        var module = this.modulesByIdentifier.get(scope.identifier);\n        if (module) {\n            module.disconnectContextForScope(scope);\n        }\n    };\n    // Modules\n    Router.prototype.connectModule = function (module) {\n        this.modulesByIdentifier.set(module.identifier, module);\n        var scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);\n        scopes.forEach(function (scope) { return module.connectContextForScope(scope); });\n    };\n    Router.prototype.disconnectModule = function (module) {\n        this.modulesByIdentifier.delete(module.identifier);\n        var scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);\n        scopes.forEach(function (scope) { return module.disconnectContextForScope(scope); });\n    };\n    return Router;\n}());\n\n//# sourceMappingURL=router.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/schema.js\nvar defaultSchema = {\n    controllerAttribute: \"data-controller\",\n    actionAttribute: \"data-action\",\n    targetAttribute: \"data-target\"\n};\n//# sourceMappingURL=schema.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/application.js\nvar __awaiter = ( false) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = ( false) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar application_spreadArrays = ( false) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\n\n\n\nvar Application = /** @class */ (function () {\n    function Application(element, schema) {\n        if (element === void 0) { element = document.documentElement; }\n        if (schema === void 0) { schema = defaultSchema; }\n        this.logger = console;\n        this.element = element;\n        this.schema = schema;\n        this.dispatcher = new Dispatcher(this);\n        this.router = new Router(this);\n    }\n    Application.start = function (element, schema) {\n        var application = new Application(element, schema);\n        application.start();\n        return application;\n    };\n    Application.prototype.start = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, domReady()];\n                    case 1:\n                        _a.sent();\n                        this.dispatcher.start();\n                        this.router.start();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Application.prototype.stop = function () {\n        this.dispatcher.stop();\n        this.router.stop();\n    };\n    Application.prototype.register = function (identifier, controllerConstructor) {\n        this.load({ identifier: identifier, controllerConstructor: controllerConstructor });\n    };\n    Application.prototype.load = function (head) {\n        var _this = this;\n        var rest = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            rest[_i - 1] = arguments[_i];\n        }\n        var definitions = Array.isArray(head) ? head : application_spreadArrays([head], rest);\n        definitions.forEach(function (definition) { return _this.router.loadDefinition(definition); });\n    };\n    Application.prototype.unload = function (head) {\n        var _this = this;\n        var rest = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            rest[_i - 1] = arguments[_i];\n        }\n        var identifiers = Array.isArray(head) ? head : application_spreadArrays([head], rest);\n        identifiers.forEach(function (identifier) { return _this.router.unloadIdentifier(identifier); });\n    };\n    Object.defineProperty(Application.prototype, \"controllers\", {\n        // Controllers\n        get: function () {\n            return this.router.contexts.map(function (context) { return context.controller; });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Application.prototype.getControllerForElementAndIdentifier = function (element, identifier) {\n        var context = this.router.getContextForElementAndIdentifier(element, identifier);\n        return context ? context.controller : null;\n    };\n    // Error handling\n    Application.prototype.handleError = function (error, message, detail) {\n        this.logger.error(\"%s\\n\\n%o\\n\\n%o\", message, error, detail);\n    };\n    return Application;\n}());\n\nfunction domReady() {\n    return new Promise(function (resolve) {\n        if (document.readyState == \"loading\") {\n            document.addEventListener(\"DOMContentLoaded\", resolve);\n        }\n        else {\n            resolve();\n        }\n    });\n}\n//# sourceMappingURL=application.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/class_properties.js\n\n\n/** @hidden */\nfunction ClassPropertiesBlessing(constructor) {\n    var classes = readInheritableStaticArrayValues(constructor, \"classes\");\n    return classes.reduce(function (properties, classDefinition) {\n        return Object.assign(properties, propertiesForClassDefinition(classDefinition));\n    }, {});\n}\nfunction propertiesForClassDefinition(key) {\n    var _a;\n    var name = key + \"Class\";\n    return _a = {},\n        _a[name] = {\n            get: function () {\n                var classes = this.classes;\n                if (classes.has(key)) {\n                    return classes.get(key);\n                }\n                else {\n                    var attribute = classes.getAttributeName(key);\n                    throw new Error(\"Missing attribute \\\"\" + attribute + \"\\\"\");\n                }\n            }\n        },\n        _a[\"has\" + capitalize(name)] = {\n            get: function () {\n                return this.classes.has(key);\n            }\n        },\n        _a;\n}\n//# sourceMappingURL=class_properties.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/target_properties.js\n\n\n/** @hidden */\nfunction TargetPropertiesBlessing(constructor) {\n    var targets = readInheritableStaticArrayValues(constructor, \"targets\");\n    return targets.reduce(function (properties, targetDefinition) {\n        return Object.assign(properties, propertiesForTargetDefinition(targetDefinition));\n    }, {});\n}\nfunction propertiesForTargetDefinition(name) {\n    var _a;\n    return _a = {},\n        _a[name + \"Target\"] = {\n            get: function () {\n                var target = this.targets.find(name);\n                if (target) {\n                    return target;\n                }\n                else {\n                    throw new Error(\"Missing target element \\\"\" + this.identifier + \".\" + name + \"\\\"\");\n                }\n            }\n        },\n        _a[name + \"Targets\"] = {\n            get: function () {\n                return this.targets.findAll(name);\n            }\n        },\n        _a[\"has\" + capitalize(name) + \"Target\"] = {\n            get: function () {\n                return this.targets.has(name);\n            }\n        },\n        _a;\n}\n//# sourceMappingURL=target_properties.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/value_properties.js\n\n\n/** @hidden */\nfunction ValuePropertiesBlessing(constructor) {\n    var valueDefinitionPairs = readInheritableStaticObjectPairs(constructor, \"values\");\n    var propertyDescriptorMap = {\n        valueDescriptorMap: {\n            get: function () {\n                var _this = this;\n                return valueDefinitionPairs.reduce(function (result, valueDefinitionPair) {\n                    var _a;\n                    var valueDescriptor = parseValueDefinitionPair(valueDefinitionPair);\n                    var attributeName = _this.data.getAttributeNameForKey(valueDescriptor.key);\n                    return Object.assign(result, (_a = {}, _a[attributeName] = valueDescriptor, _a));\n                }, {});\n            }\n        }\n    };\n    return valueDefinitionPairs.reduce(function (properties, valueDefinitionPair) {\n        return Object.assign(properties, propertiesForValueDefinitionPair(valueDefinitionPair));\n    }, propertyDescriptorMap);\n}\n/** @hidden */\nfunction propertiesForValueDefinitionPair(valueDefinitionPair) {\n    var _a;\n    var definition = parseValueDefinitionPair(valueDefinitionPair);\n    var type = definition.type, key = definition.key, name = definition.name;\n    var read = readers[type], write = writers[type] || writers.default;\n    return _a = {},\n        _a[name] = {\n            get: function () {\n                var value = this.data.get(key);\n                if (value !== null) {\n                    return read(value);\n                }\n                else {\n                    return definition.defaultValue;\n                }\n            },\n            set: function (value) {\n                if (value === undefined) {\n                    this.data.delete(key);\n                }\n                else {\n                    this.data.set(key, write(value));\n                }\n            }\n        },\n        _a[\"has\" + capitalize(name)] = {\n            get: function () {\n                return this.data.has(key);\n            }\n        },\n        _a;\n}\nfunction parseValueDefinitionPair(_a) {\n    var token = _a[0], typeConstant = _a[1];\n    var type = parseValueTypeConstant(typeConstant);\n    return valueDescriptorForTokenAndType(token, type);\n}\nfunction parseValueTypeConstant(typeConstant) {\n    switch (typeConstant) {\n        case Array: return \"array\";\n        case Boolean: return \"boolean\";\n        case Number: return \"number\";\n        case Object: return \"object\";\n        case String: return \"string\";\n    }\n    throw new Error(\"Unknown value type constant \\\"\" + typeConstant + \"\\\"\");\n}\nfunction valueDescriptorForTokenAndType(token, type) {\n    var key = dasherize(token) + \"-value\";\n    return {\n        type: type,\n        key: key,\n        name: camelize(key),\n        get defaultValue() { return defaultValuesByType[type]; }\n    };\n}\nvar defaultValuesByType = {\n    get array() { return []; },\n    boolean: false,\n    number: 0,\n    get object() { return {}; },\n    string: \"\"\n};\nvar readers = {\n    array: function (value) {\n        var array = JSON.parse(value);\n        if (!Array.isArray(array)) {\n            throw new TypeError(\"Expected array\");\n        }\n        return array;\n    },\n    boolean: function (value) {\n        return !(value == \"0\" || value == \"false\");\n    },\n    number: function (value) {\n        return parseFloat(value);\n    },\n    object: function (value) {\n        var object = JSON.parse(value);\n        if (object === null || typeof object != \"object\" || Array.isArray(object)) {\n            throw new TypeError(\"Expected object\");\n        }\n        return object;\n    },\n    string: function (value) {\n        return value;\n    }\n};\nvar writers = {\n    default: writeString,\n    array: writeJSON,\n    object: writeJSON\n};\nfunction writeJSON(value) {\n    return JSON.stringify(value);\n}\nfunction writeString(value) {\n    return \"\" + value;\n}\n//# sourceMappingURL=value_properties.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/controller.js\n\n\n\nvar Controller = /** @class */ (function () {\n    function Controller(context) {\n        this.context = context;\n    }\n    Object.defineProperty(Controller.prototype, \"application\", {\n        get: function () {\n            return this.context.application;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Controller.prototype, \"scope\", {\n        get: function () {\n            return this.context.scope;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Controller.prototype, \"element\", {\n        get: function () {\n            return this.scope.element;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Controller.prototype, \"identifier\", {\n        get: function () {\n            return this.scope.identifier;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Controller.prototype, \"targets\", {\n        get: function () {\n            return this.scope.targets;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Controller.prototype, \"classes\", {\n        get: function () {\n            return this.scope.classes;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Controller.prototype, \"data\", {\n        get: function () {\n            return this.scope.data;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Controller.prototype.initialize = function () {\n        // Override in your subclass to set up initial controller state\n    };\n    Controller.prototype.connect = function () {\n        // Override in your subclass to respond when the controller is connected to the DOM\n    };\n    Controller.prototype.disconnect = function () {\n        // Override in your subclass to respond when the controller is disconnected from the DOM\n    };\n    Controller.blessings = [ClassPropertiesBlessing, TargetPropertiesBlessing, ValuePropertiesBlessing];\n    Controller.targets = [];\n    Controller.values = {};\n    return Controller;\n}());\n\n//# sourceMappingURL=controller.js.map\n;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/index.js\n\n\n\n\n//# sourceMappingURL=index.js.map\n;// CONCATENATED MODULE: ./node_modules/stimulus/index.js\n\n\n\n/***/ }),\n\n/***/ 470:\n/***/ ((__unused_webpack_module, exports, __nested_webpack_require_155185__) => {\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UploaderController = exports.TooltipController = exports.setTooltipText = exports.setTooltipHtml = exports.TableController = exports.showPopover = exports.PopoverController = exports.BasePopoverController = exports.hidePopover = exports.detachPopover = exports.attachPopover = exports.TabListController = exports.showModal = exports.ModalController = exports.hideModal = exports.ExpandableController = void 0;\n// export all controllers *with helpers* so they can be bulk re-exported by the package entry point\nvar s_expandable_control_1 = __nested_webpack_require_155185__(601);\nObject.defineProperty(exports, \"ExpandableController\", ({ enumerable: true, get: function () { return s_expandable_control_1.ExpandableController; } }));\nvar s_modal_1 = __nested_webpack_require_155185__(181);\nObject.defineProperty(exports, \"hideModal\", ({ enumerable: true, get: function () { return s_modal_1.hideModal; } }));\nObject.defineProperty(exports, \"ModalController\", ({ enumerable: true, get: function () { return s_modal_1.ModalController; } }));\nObject.defineProperty(exports, \"showModal\", ({ enumerable: true, get: function () { return s_modal_1.showModal; } }));\nvar s_navigation_tablist_1 = __nested_webpack_require_155185__(642);\nObject.defineProperty(exports, \"TabListController\", ({ enumerable: true, get: function () { return s_navigation_tablist_1.TabListController; } }));\nvar s_popover_1 = __nested_webpack_require_155185__(388);\nObject.defineProperty(exports, \"attachPopover\", ({ enumerable: true, get: function () { return s_popover_1.attachPopover; } }));\nObject.defineProperty(exports, \"detachPopover\", ({ enumerable: true, get: function () { return s_popover_1.detachPopover; } }));\nObject.defineProperty(exports, \"hidePopover\", ({ enumerable: true, get: function () { return s_popover_1.hidePopover; } }));\nObject.defineProperty(exports, \"BasePopoverController\", ({ enumerable: true, get: function () { return s_popover_1.BasePopoverController; } }));\nObject.defineProperty(exports, \"PopoverController\", ({ enumerable: true, get: function () { return s_popover_1.PopoverController; } }));\nObject.defineProperty(exports, \"showPopover\", ({ enumerable: true, get: function () { return s_popover_1.showPopover; } }));\nvar s_table_1 = __nested_webpack_require_155185__(753);\nObject.defineProperty(exports, \"TableController\", ({ enumerable: true, get: function () { return s_table_1.TableController; } }));\nvar s_tooltip_1 = __nested_webpack_require_155185__(355);\nObject.defineProperty(exports, \"setTooltipHtml\", ({ enumerable: true, get: function () { return s_tooltip_1.setTooltipHtml; } }));\nObject.defineProperty(exports, \"setTooltipText\", ({ enumerable: true, get: function () { return s_tooltip_1.setTooltipText; } }));\nObject.defineProperty(exports, \"TooltipController\", ({ enumerable: true, get: function () { return s_tooltip_1.TooltipController; } }));\nvar s_uploader_1 = __nested_webpack_require_155185__(637);\nObject.defineProperty(exports, \"UploaderController\", ({ enumerable: true, get: function () { return s_uploader_1.UploaderController; } }));\n\n\n/***/ }),\n\n/***/ 601:\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_158328__) {\n\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ExpandableController = void 0;\nvar Stacks = __nested_webpack_require_158328__(36);\n// Radio buttons only trigger a change event when they're *checked*, but not when\n// they're *unchecked*. Therefore, if we have an active `s-expandable-control` in\n// the document, we listen for change events on *all* radio buttons and find any\n// other radio buttons in the same `name` group, triggering a custom event on all\n// of them so the controller can re-evaluate.\n//\n// We're keeping a count of how many of these controllers are connected to the DOM,\n// so only have this global listener when we actually need it.\nvar RADIO_OFF_EVENT = \"s-expandable-control:radio-off\";\nfunction globalChangeListener(e) {\n    var target = e.target;\n    if (!(target instanceof HTMLInputElement) || target.nodeName !== \"INPUT\" || target.type !== \"radio\") {\n        return;\n    }\n    document.querySelectorAll('input[type=\"radio\"][name=\"' + target.name + '\"]')\n        .forEach(function (other) {\n        if (other === e.target) {\n            return;\n        }\n        var customEvent;\n        try {\n            customEvent = new Event(RADIO_OFF_EVENT);\n        }\n        catch (ex) {\n            // Internet Explorer\n            customEvent = document.createEvent(\"Event\");\n            customEvent.initEvent(RADIO_OFF_EVENT, true, true);\n        }\n        other.dispatchEvent(customEvent);\n    });\n}\nvar refCount = 0;\nfunction globalChangeListenerRequired(required) {\n    if (required) {\n        refCount++;\n        if (refCount === 1) {\n            document.body.addEventListener(\"change\", globalChangeListener);\n        }\n    }\n    else {\n        refCount--;\n        if (refCount === 0) {\n            document.body.removeEventListener(\"change\", globalChangeListener);\n        }\n    }\n}\nvar ExpandableController = /** @class */ (function (_super) {\n    __extends(ExpandableController, _super);\n    function ExpandableController() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.lastKeydownClickTimestamp = 0;\n        return _this;\n    }\n    ExpandableController.prototype.initialize = function () {\n        if (this.element.nodeName === \"INPUT\" && [\"radio\", \"checkbox\"].indexOf(this.element.type) >= 0) {\n            this.isCollapsed = this._isCollapsedForCheckable.bind(this);\n            this.events = [\"change\", RADIO_OFF_EVENT];\n            this.isCheckable = true;\n            this.isRadio = this.element.type === \"radio\";\n        }\n        else {\n            this.isCollapsed = this._isCollapsedForClickable.bind(this);\n            this.events = [\"click\", \"keydown\"];\n        }\n        this.listener = this.listener.bind(this);\n    };\n    ;\n    // for non-checkable elements, the initial source of truth is the collapsed/expanded\n    // state of the controlled element (unless the element doesn't exist)\n    ExpandableController.prototype._isCollapsedForClickable = function () {\n        var cc = this.controlledExpandables;\n        // the element is considered collapsed if *any* target element is collapsed\n        return cc.length > 0 ? !cc.every(function (element) { return element.classList.contains(\"is-expanded\"); }) : this.element.getAttribute(\"aria-expanded\") === \"false\";\n    };\n    ;\n    // for checkable elements, the initial source of truth is the checked state\n    ExpandableController.prototype._isCollapsedForCheckable = function () {\n        return !this.element.checked;\n    };\n    ;\n    Object.defineProperty(ExpandableController.prototype, \"controlledExpandables\", {\n        get: function () {\n            var attr = this.element.getAttribute(\"aria-controls\");\n            if (!attr) {\n                throw \"[aria-controls=\\\"targetId1 ... targetIdN\\\"] attribute required\";\n            }\n            var result = attr.split(/\\s+/g)\n                .map(function (s) { return document.getElementById(s); })\n                .filter(function (e) { return !!e; });\n            if (!result.length) {\n                throw \"couldn't find controls\";\n            }\n            return result;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ;\n    ExpandableController.prototype._dispatchShowHideEvent = function (isShow) {\n        this.triggerEvent(isShow ? \"show\" : \"hide\");\n    };\n    ;\n    ExpandableController.prototype._toggleClass = function (doAdd) {\n        if (!this.data.has(\"toggle-class\")) {\n            return;\n        }\n        var cl = this.element.classList;\n        var toggleClass = this.data.get(\"toggle-class\");\n        if (!toggleClass) {\n            throw \"couldn't find toggle class\";\n        }\n        toggleClass.split(/\\s+/).forEach(function (cls) {\n            cl.toggle(cls, !!doAdd);\n        });\n    };\n    ;\n    ExpandableController.prototype.listener = function (e) {\n        var newCollapsed;\n        if (this.isCheckable) {\n            newCollapsed = !this.element.checked;\n        }\n        else {\n            if (e.type == \"keydown\" && (e instanceof KeyboardEvent && e.keyCode != 13 && e.keyCode != 32)) {\n                return;\n            }\n            if (e.target !== e.currentTarget && [\"A\", \"BUTTON\"].indexOf(e.target.nodeName) >= 0) {\n                return;\n            }\n            e.preventDefault();\n            // Prevent \"click\" events from toggling the expandable within 300ms of \"keydown\".\n            // e.preventDefault() should have done the same, but https://bugzilla.mozilla.org/show_bug.cgi?id=1487102\n            // doesn't guarantee it.\n            if (e.type == \"keydown\") {\n                this.lastKeydownClickTimestamp = Date.now();\n            }\n            else if (e.type == \"click\" && Date.now() - this.lastKeydownClickTimestamp < 300) {\n                return;\n            }\n            newCollapsed = this.element.getAttribute(\"aria-expanded\") === \"true\";\n            if (e.type === \"click\") {\n                this.element.blur();\n            }\n        }\n        this.element.setAttribute(\"aria-expanded\", newCollapsed ? \"false\" : \"true\");\n        for (var _i = 0, _a = this.controlledExpandables; _i < _a.length; _i++) {\n            var controlledElement = _a[_i];\n            controlledElement.classList.toggle(\"is-expanded\", !newCollapsed);\n        }\n        this._dispatchShowHideEvent(!newCollapsed);\n        this._toggleClass(!newCollapsed);\n    };\n    ;\n    ExpandableController.prototype.connect = function () {\n        var _this = this;\n        this.events.forEach(function (e) {\n            _this.element.addEventListener(e, _this.listener.bind(_this));\n        }, this);\n        if (this.isRadio) {\n            globalChangeListenerRequired(true);\n        }\n        // synchronize state -- in all cases, this means setting the correct `aria-expanded`\n        // attribute; for checkable controls this also means setting the `is-collapsed` class.\n        // Note: aria-expanded is currently an invalid attribute on radio elements\n        // Support for aria-expanded is being debated by the W3C https://github.com/w3c/aria/issues/1404 as recently as June 2022\n        if (!this.isRadio) {\n            this.element.setAttribute(\"aria-expanded\", this.isCollapsed() ? \"false\" : \"true\");\n        }\n        if (this.isCheckable) {\n            var cc = this.controlledExpandables;\n            if (cc.length) {\n                var expected_1 = !this.isCollapsed();\n                // if any element does not match the expected state, set them all to the expected state\n                if (cc.some(function (element) { return element.classList.contains(\"is-expanded\") !== expected_1; })) {\n                    for (var _i = 0, _a = this.controlledExpandables; _i < _a.length; _i++) {\n                        var controlledElement = _a[_i];\n                        controlledElement.classList.toggle(\"is-expanded\", expected_1);\n                    }\n                    this._dispatchShowHideEvent(expected_1);\n                    this._toggleClass(expected_1);\n                }\n            }\n        }\n    };\n    ;\n    ExpandableController.prototype.disconnect = function () {\n        var _this = this;\n        this.events.forEach(function (e) {\n            _this.element.removeEventListener(e, _this.listener.bind(_this));\n        }, this);\n        if (this.isRadio) {\n            globalChangeListenerRequired(false);\n        }\n    };\n    ;\n    return ExpandableController;\n}(Stacks.StacksController));\nexports.ExpandableController = ExpandableController;\n\n\n/***/ }),\n\n/***/ 181:\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_167645__) {\n\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hideModal = exports.showModal = exports.ModalController = void 0;\nvar Stacks = __nested_webpack_require_167645__(36);\nvar ModalController = /** @class */ (function (_super) {\n    __extends(ModalController, _super);\n    function ModalController() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ModalController.prototype.connect = function () {\n        this.validate();\n    };\n    /**\n     * Disconnects all added event listeners on controller disconnect\n     */\n    ModalController.prototype.disconnect = function () {\n        this.unbindDocumentEvents();\n    };\n    ;\n    /**\n     * Toggles the visibility of the modal\n     */\n    ModalController.prototype.toggle = function (dispatcher) {\n        if (dispatcher === void 0) { dispatcher = null; }\n        this._toggle(undefined, dispatcher);\n    };\n    /**\n     * Shows the modal\n     */\n    ModalController.prototype.show = function (dispatcher) {\n        if (dispatcher === void 0) { dispatcher = null; }\n        this._toggle(true, dispatcher);\n    };\n    /**\n     * Hides the modal\n     */\n    ModalController.prototype.hide = function (dispatcher) {\n        if (dispatcher === void 0) { dispatcher = null; }\n        this._toggle(false, dispatcher);\n    };\n    /**\n     * Validates the modal settings and attempts to set necessary internal variables\n     */\n    ModalController.prototype.validate = function () {\n        // check for returnElement support\n        var returnElementSelector = this.data.get(\"return-element\");\n        if (returnElementSelector) {\n            this.returnElement = document.querySelector(returnElementSelector);\n            if (!this.returnElement) {\n                throw \"Unable to find element by return-element selector: \" + returnElementSelector;\n            }\n        }\n    };\n    /**\n     * Toggles the visibility of the modal element\n     * @param show Optional parameter that force shows/hides the element or toggles it if left undefined\n     */\n    ModalController.prototype._toggle = function (show, dispatcher) {\n        var _this = this;\n        if (dispatcher === void 0) { dispatcher = null; }\n        var toShow = show;\n        var isVisible = this.modalTarget.getAttribute(\"aria-hidden\") === \"false\";\n        // if we're letting the class toggle, we need to figure out if the popover is visible manually\n        if (typeof toShow === \"undefined\") {\n            toShow = !isVisible;\n        }\n        // if the state matches the disired state, return without changing anything\n        if ((toShow && isVisible) || (!toShow && !isVisible)) {\n            return;\n        }\n        var dispatchingElement = this.getDispatcher(dispatcher);\n        // show/hide events trigger before toggling the class\n        var triggeredEvent = this.triggerEvent(toShow ? \"show\" : \"hide\", {\n            returnElement: this.returnElement,\n            dispatcher: this.getDispatcher(dispatchingElement)\n        }, this.modalTarget);\n        // if this pre-show/hide event was prevented, don't attempt to continue changing the modal state\n        if (triggeredEvent.defaultPrevented) {\n            return;\n        }\n        this.returnElement = triggeredEvent.detail.returnElement;\n        this.modalTarget.setAttribute(\"aria-hidden\", toShow ? \"false\" : \"true\");\n        if (toShow) {\n            this.bindDocumentEvents();\n            this.focusInsideModal();\n        }\n        else {\n            this.unbindDocumentEvents();\n            this.focusReturnElement();\n            this.removeModalOnHide();\n        }\n        // check for transitionend support\n        var supportsTransitionEnd = (this.modalTarget).ontransitionend !== undefined;\n        // shown/hidden events trigger after toggling the class\n        if (supportsTransitionEnd) {\n            // wait until after the modal finishes transitioning to fire the event\n            this.modalTarget.addEventListener(\"transitionend\", function () {\n                //TODO this is firing waaay to soon?\n                _this.triggerEvent(toShow ? \"shown\" : \"hidden\", {\n                    dispatcher: dispatchingElement\n                }, _this.modalTarget);\n            }, { once: true });\n        }\n        else {\n            this.triggerEvent(toShow ? \"shown\" : \"hidden\", {\n                dispatcher: dispatchingElement\n            }, this.modalTarget);\n        }\n    };\n    /**\n     * Listens for the s-modal:hidden event and focuses the returnElement when it is fired\n     */\n    ModalController.prototype.focusReturnElement = function () {\n        var _this = this;\n        if (!this.returnElement) {\n            return;\n        }\n        this.modalTarget.addEventListener(\"s-modal:hidden\", function () {\n            // double check the element still exists when the event is called\n            if (_this.returnElement && document.body.contains(_this.returnElement)) {\n                _this.returnElement.focus();\n            }\n        }, { once: true });\n    };\n    /**\n     * Remove the element on hide if the `remove-when-hidden` flag is set\n     */\n    ModalController.prototype.removeModalOnHide = function () {\n        var _this = this;\n        if (this.data.get(\"remove-when-hidden\") !== \"true\") {\n            return;\n        }\n        this.modalTarget.addEventListener(\"s-modal:hidden\", function () {\n            _this.element.remove();\n        }, { once: true });\n    };\n    /**\n     * Gets all elements within the modal that could receive keyboard focus.\n     */\n    ModalController.prototype.getAllTabbables = function () {\n        return Array.from(this.modalTarget.querySelectorAll(\"[href], input, select, textarea, button, [tabindex]\"))\n            .filter(function (el) { return el.matches(\":not([disabled]):not([tabindex='-1'])\"); });\n    };\n    /**\n     * Returns the first visible element in an array or `undefined` if no elements are visible.\n     */\n    ModalController.prototype.firstVisible = function (elements) {\n        // https://stackoverflow.com/a/21696585\n        return elements.find(function (el) { return el.offsetParent !== null; });\n    };\n    /**\n     * Returns the last visible element in an array or `undefined` if no elements are visible.\n     */\n    ModalController.prototype.lastVisible = function (elements) {\n        return this.firstVisible(__spreadArray([], elements, true).reverse());\n    };\n    /**\n     * Attempts to shift keyboard focus into the modal.\n     * If elements with `data-s-modal-target=\"initialFocus\"` are present and visible, one of those will be selected.\n     * Otherwise, the first visible focusable element will receive focus.\n     */\n    ModalController.prototype.focusInsideModal = function () {\n        var _this = this;\n        this.modalTarget.addEventListener(\"s-modal:shown\", function () {\n            var _a;\n            var initialFocus = (_a = _this.firstVisible(_this.initialFocusTargets)) !== null && _a !== void 0 ? _a : _this.firstVisible(_this.getAllTabbables());\n            initialFocus === null || initialFocus === void 0 ? void 0 : initialFocus.focus();\n        }, { once: true });\n    };\n    /**\n     * Returns keyboard focus to the modal if it has left or is about to leave.\n     */\n    ModalController.prototype.keepFocusWithinModal = function (e) {\n        // If somehow the user has tabbed out of the modal or if focus started outside the modal, push them to the first item.\n        if (!this.modalTarget.contains(e.target)) {\n            var focusTarget = this.firstVisible(this.getAllTabbables());\n            if (focusTarget) {\n                e.preventDefault();\n                focusTarget.focus();\n            }\n            return;\n        }\n        // If we observe a tab keydown and we're on an edge, cycle the focus to the other side.\n        if (e.key === \"Tab\") {\n            var tabbables = this.getAllTabbables();\n            var firstTabbable = this.firstVisible(tabbables);\n            var lastTabbable = this.lastVisible(tabbables);\n            if (firstTabbable && lastTabbable) {\n                if (firstTabbable === lastTabbable) {\n                    e.preventDefault();\n                    firstTabbable.focus();\n                }\n                else if (e.shiftKey && e.target === firstTabbable) {\n                    e.preventDefault();\n                    lastTabbable.focus();\n                }\n                else if (!e.shiftKey && e.target === lastTabbable) {\n                    e.preventDefault();\n                    firstTabbable.focus();\n                }\n            }\n        }\n    };\n    /**\n     * Binds global events to the document for hiding popovers on user interaction\n     */\n    ModalController.prototype.bindDocumentEvents = function () {\n        // in order for removeEventListener to remove the right event, this bound function needs a constant reference\n        this._boundClickFn = this._boundClickFn || this.hideOnOutsideClick.bind(this);\n        this._boundKeypressFn = this._boundKeypressFn || this.hideOnEscapePress.bind(this);\n        this._boundTabTrap = this._boundTabTrap || this.keepFocusWithinModal.bind(this);\n        document.addEventListener(\"mousedown\", this._boundClickFn);\n        document.addEventListener(\"keyup\", this._boundKeypressFn);\n        document.addEventListener(\"keydown\", this._boundTabTrap);\n    };\n    /**\n     * Unbinds global events to the document for hiding popovers on user interaction\n     */\n    ModalController.prototype.unbindDocumentEvents = function () {\n        document.removeEventListener(\"mousedown\", this._boundClickFn);\n        document.removeEventListener(\"keyup\", this._boundKeypressFn);\n        document.removeEventListener(\"keydown\", this._boundTabTrap);\n    };\n    /**\n     * Forces the popover to hide if a user clicks outside of it or its reference element\n     */\n    ModalController.prototype.hideOnOutsideClick = function (e) {\n        var target = e.target;\n        // check if the document was clicked inside either the toggle element or the modal itself\n        // note: .contains also returns true if the node itself matches the target element\n        if (!this.modalTarget.querySelector(\".s-modal--dialog\").contains(target) && document.body.contains(target)) {\n            this._toggle(false, e);\n        }\n    };\n    /**\n     * Forces the popover to hide if the user presses escape while it, one of its childen, or the reference element are focused\n     */\n    ModalController.prototype.hideOnEscapePress = function (e) {\n        // if the ESC key (27) wasn't pressed or if no popovers are showing, return\n        if (e.which !== 27 || this.modalTarget.getAttribute(\"aria-hidden\") === \"true\") {\n            return;\n        }\n        this._toggle(false, e);\n    };\n    /**\n     * Determines the correct dispatching element from a potential input\n     * @param dispatcher The event or element to get the dispatcher from\n     */\n    ModalController.prototype.getDispatcher = function (dispatcher) {\n        if (dispatcher === void 0) { dispatcher = null; }\n        if (dispatcher instanceof Event) {\n            return dispatcher.target;\n        }\n        else if (dispatcher instanceof Element) {\n            return dispatcher;\n        }\n        else {\n            return this.element;\n        }\n    };\n    ModalController.targets = [\"modal\", \"initialFocus\"];\n    return ModalController;\n}(Stacks.StacksController));\nexports.ModalController = ModalController;\n/**\n * Helper to manually show an s-modal element via external JS\n * @param element the element the `data-controller=\"s-modal\"` attribute is on\n */\nfunction showModal(element) {\n    toggleModal(element, true);\n}\nexports.showModal = showModal;\n/**\n * Helper to manually hide an s-modal element via external JS\n * @param element the element the `data-controller=\"s-modal\"` attribute is on\n */\nfunction hideModal(element) {\n    toggleModal(element, false);\n}\nexports.hideModal = hideModal;\n/**\n * Helper to manually show an s-modal element via external JS\n * @param element the element the `data-controller=\"s-modal\"` attribute is on\n * @param show whether to force show/hide the modal; toggles the modal if left undefined\n */\nfunction toggleModal(element, show) {\n    var controller = Stacks.application.getControllerForElementAndIdentifier(element, \"s-modal\");\n    if (!controller) {\n        throw \"Unable to get s-modal controller from element\";\n    }\n    show ? controller.show() : controller.hide();\n}\n\n\n/***/ }),\n\n/***/ 642:\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_181292__) {\n\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TabListController = void 0;\nvar Stacks = __nested_webpack_require_181292__(36);\nvar TabListController = /** @class */ (function (_super) {\n    __extends(TabListController, _super);\n    function TabListController() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TabListController.prototype.connect = function () {\n        _super.prototype.connect.call(this);\n        this.boundSelectTab = this.selectTab.bind(this);\n        this.boundHandleKeydown = this.handleKeydown.bind(this);\n        for (var _i = 0, _a = this.tabTargets; _i < _a.length; _i++) {\n            var tab = _a[_i];\n            tab.addEventListener(\"click\", this.boundSelectTab);\n            tab.addEventListener(\"keydown\", this.boundHandleKeydown);\n        }\n    };\n    TabListController.prototype.disconnect = function () {\n        _super.prototype.disconnect.call(this);\n        for (var _i = 0, _a = this.tabTargets; _i < _a.length; _i++) {\n            var tab = _a[_i];\n            tab.removeEventListener(\"click\", this.boundSelectTab);\n            tab.removeEventListener(\"keydown\", this.boundHandleKeydown);\n        }\n    };\n    Object.defineProperty(TabListController.prototype, \"tabTargets\", {\n        /**\n         * Gets all tabs within the controller.\n         */\n        get: function () {\n            return Array.from(this.element.querySelectorAll(\"[role=tab]\"));\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Handles click events on individual tabs, causing them to be selected.\n     */\n    TabListController.prototype.selectTab = function (event) {\n        this.switchToTab(event.currentTarget);\n    };\n    /**\n     * Handles left and right arrow keydown events on individual tabs,\n     * selecting the adjacent tab corresponding to the event.\n     */\n    TabListController.prototype.handleKeydown = function (event) {\n        var _a;\n        var tabElement = event.currentTarget;\n        var tabs = this.tabTargets;\n        var tabIndex = tabs.indexOf(tabElement);\n        if (event.key === \"ArrowRight\") {\n            tabIndex++;\n        }\n        else if (event.key === \"ArrowLeft\") {\n            tabIndex--;\n        }\n        else {\n            return;\n        }\n        // Use circular navigation when users go past the first or last tab.\n        if (tabIndex < 0) {\n            tabIndex = tabs.length - 1;\n        }\n        if (tabIndex >= tabs.length) {\n            tabIndex = 0;\n        }\n        tabElement = tabs[tabIndex];\n        this.switchToTab(tabElement);\n        // Focus the newly selected tab so it can receive keyboard events.\n        (_a = this.selectedTab) === null || _a === void 0 ? void 0 : _a.focus();\n    };\n    /**\n     * Attempts to switch to a new tab, doing nothing if the tab is already selected or\n     * the s-navigation-tablist:select event is prevented.\n     */\n    TabListController.prototype.switchToTab = function (newTab) {\n        var oldTab = this.selectedTab;\n        if (oldTab === newTab) {\n            return;\n        }\n        if (this.triggerEvent(\"select\", { oldTab: oldTab, newTab: newTab }).defaultPrevented) {\n            return;\n        }\n        this.selectedTab = newTab;\n        this.triggerEvent(\"selected\", { oldTab: oldTab, newTab: newTab });\n    };\n    Object.defineProperty(TabListController.prototype, \"selectedTab\", {\n        /**\n         * Returns the currently selected tab or null if no tabs are selected.\n         */\n        get: function () {\n            return this.tabTargets.find(function (e) { return e.getAttribute(\"aria-selected\") === \"true\"; }) || null;\n        },\n        /**\n         * Switches the tablist to the provided tab, updating the tabs and panels\n         * to reflect the change.\n         * @param selectedTab The tab to select. If `null` is provided or the element\n         * is not a valid tab, all tabs will be unselected.\n         */\n        set: function (selectedTab) {\n            for (var _i = 0, _a = this.tabTargets; _i < _a.length; _i++) {\n                var tab = _a[_i];\n                var panelId = tab.getAttribute('aria-controls');\n                var panel = panelId ? document.getElementById(panelId) : null;\n                if (tab === selectedTab) {\n                    tab.classList.add('is-selected');\n                    tab.setAttribute('aria-selected', 'true');\n                    tab.removeAttribute('tabindex');\n                    panel === null || panel === void 0 ? void 0 : panel.classList.remove('d-none');\n                }\n                else {\n                    tab.classList.remove('is-selected');\n                    tab.setAttribute('aria-selected', 'false');\n                    tab.setAttribute('tabindex', '-1');\n                    panel === null || panel === void 0 ? void 0 : panel.classList.add('d-none');\n                }\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return TabListController;\n}(Stacks.StacksController));\nexports.TabListController = TabListController;\n\n\n/***/ }),\n\n/***/ 388:\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_187230__) {\n\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.detachPopover = exports.attachPopover = exports.hidePopover = exports.showPopover = exports.PopoverController = exports.BasePopoverController = void 0;\nvar core_1 = __nested_webpack_require_187230__(492);\nvar Stacks = __nested_webpack_require_187230__(36);\nvar BasePopoverController = /** @class */ (function (_super) {\n    __extends(BasePopoverController, _super);\n    function BasePopoverController() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(BasePopoverController.prototype, \"isVisible\", {\n        /**\n         * Returns true if the if the popover is currently visible.\n         */\n        get: function () {\n            var popoverElement = this.popoverElement;\n            return popoverElement ? popoverElement.classList.contains(\"is-visible\") : false;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BasePopoverController.prototype, \"isInViewport\", {\n        /**\n         * Gets whether the element is visible in the browser's viewport.\n         */\n        get: function () {\n            var element = this.popoverElement;\n            if (!this.isVisible || !element) {\n                return false;\n            }\n            // From https://stackoverflow.com/a/5354536.  Theoretically, this could be calculated using Popper's detectOverflow function,\n            // but it's unclear how to access that with our current configuration.\n            var rect = element.getBoundingClientRect();\n            var viewHeight = Math.max(document.documentElement.clientHeight, window.innerHeight);\n            var viewWidth = Math.max(document.documentElement.clientWidth, window.innerWidth);\n            return rect.bottom > 0 && rect.top < viewHeight && rect.right > 0 && rect.left < viewWidth;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BasePopoverController.prototype, \"shouldHideOnOutsideClick\", {\n        get: function () {\n            var hideBehavior = this.data.get(\"hide-on-outside-click\");\n            switch (hideBehavior) {\n                case \"after-dismissal\":\n                case \"never\":\n                    return false;\n                case \"if-in-viewport\":\n                    return this.isInViewport;\n                default:\n                    return true;\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Initializes and validates controller variables\n     */\n    BasePopoverController.prototype.connect = function () {\n        _super.prototype.connect.call(this);\n        this.validate();\n        if (this.isVisible) {\n            // just call initialize here, not show. This keeps already visible popovers from adding/firing document events\n            this.initializePopper();\n        }\n        else if (this.data.get(\"auto-show\") === \"true\") {\n            this.show(null);\n        }\n        this.data.delete(\"auto-show\");\n    };\n    /**\n     * Cleans up popper.js elements and disconnects all added event listeners\n     */\n    BasePopoverController.prototype.disconnect = function () {\n        this.hide();\n        if (this.popper) {\n            this.popper.destroy();\n            // eslint-disable-next-line\n            // @ts-ignore The operand of a 'delete' operator must be optional .ts(2790)\n            delete this.popper;\n        }\n        _super.prototype.disconnect.call(this);\n    };\n    /**\n     * Toggles the visibility of the popover\n     */\n    BasePopoverController.prototype.toggle = function (dispatcher) {\n        if (dispatcher === void 0) { dispatcher = null; }\n        this.isVisible ? this.hide(dispatcher) : this.show(dispatcher);\n    };\n    /**\n     * Shows the popover if not already visible\n     */\n    BasePopoverController.prototype.show = function (dispatcher) {\n        if (dispatcher === void 0) { dispatcher = null; }\n        if (this.isVisible) {\n            return;\n        }\n        var dispatcherElement = this.getDispatcher(dispatcher);\n        if (this.triggerEvent(\"show\", {\n            dispatcher: dispatcherElement\n        }).defaultPrevented) {\n            return;\n        }\n        if (!this.popper) {\n            this.initializePopper();\n        }\n        this.popoverElement.classList.add(\"is-visible\");\n        // ensure the popper has been positioned correctly\n        this.scheduleUpdate();\n        this.shown(dispatcherElement);\n    };\n    /**\n     * Hides the popover if not already hidden\n     */\n    BasePopoverController.prototype.hide = function (dispatcher) {\n        if (dispatcher === void 0) { dispatcher = null; }\n        if (!this.isVisible) {\n            return;\n        }\n        var dispatcherElement = this.getDispatcher(dispatcher);\n        if (this.triggerEvent(\"hide\", {\n            dispatcher: dispatcherElement\n        }).defaultPrevented) {\n            return;\n        }\n        this.popoverElement.classList.remove(\"is-visible\");\n        if (this.popper) {\n            // completely destroy the popper on hide; this is in line with Popper.js's performance recommendations\n            this.popper.destroy();\n            // eslint-disable-next-line\n            // @ts-ignore The operand of a 'delete' operator must be optional .ts(2790)\n            delete this.popper;\n        }\n        // on first interaction, hide-on-outside-click with value \"after-dismissal\" reverts to the default behavior\n        if (this.data.get(\"hide-on-outside-click\") === \"after-dismissal\") {\n            this.data.delete(\"hide-on-outside-click\");\n        }\n        this.hidden(dispatcherElement);\n    };\n    /**\n     * Binds document events for this popover and fires the shown event\n     */\n    BasePopoverController.prototype.shown = function (dispatcher) {\n        if (dispatcher === void 0) { dispatcher = null; }\n        this.bindDocumentEvents();\n        this.triggerEvent(\"shown\", {\n            dispatcher: dispatcher\n        });\n    };\n    /**\n     * Unbinds document events for this popover and fires the hidden event\n     */\n    BasePopoverController.prototype.hidden = function (dispatcher) {\n        if (dispatcher === void 0) { dispatcher = null; }\n        this.unbindDocumentEvents();\n        this.triggerEvent(\"hidden\", {\n            dispatcher: dispatcher\n        });\n    };\n    /**\n     * Generates the popover if not found during initialization\n     */\n    BasePopoverController.prototype.generatePopover = function () {\n        return null;\n    };\n    /**\n     * Initializes the Popper for this instance\n     */\n    BasePopoverController.prototype.initializePopper = function () {\n        this.popper = (0, core_1.createPopper)(this.referenceElement, this.popoverElement, {\n            placement: this.data.get(\"placement\") || \"bottom\",\n            modifiers: [\n                {\n                    name: \"offset\",\n                    options: {\n                        offset: [0, 10], // The entire popover should be 10px away from the element\n                    }\n                },\n                {\n                    name: \"arrow\",\n                    options: {\n                        element: \".s-popover--arrow\"\n                    },\n                },\n            ]\n        });\n    };\n    /**\n     * Validates the popover settings and attempts to set necessary internal variables\n     */\n    BasePopoverController.prototype.validate = function () {\n        var referenceSelector = this.data.get(\"reference-selector\");\n        this.referenceElement = this.element;\n        // if there is an alternative reference selector and that element exists, use it (and throw if it isn't found)\n        if (referenceSelector) {\n            this.referenceElement = this.element.querySelector(referenceSelector);\n            if (!this.referenceElement) {\n                throw \"Unable to find element by reference selector: \" + referenceSelector;\n            }\n        }\n        var popoverId = this.referenceElement.getAttribute(this.popoverSelectorAttribute);\n        var popoverElement = null;\n        // if the popover is named, attempt to fetch it (and throw an error if it doesn't exist)\n        if (popoverId) {\n            popoverElement = document.getElementById(popoverId);\n            if (!popoverElement) {\n                throw \"[\".concat(this.popoverSelectorAttribute, \"=\\\"{POPOVER_ID}\\\"] required\");\n            }\n        }\n        // if the popover isn't named, attempt to generate it\n        else {\n            popoverElement = this.generatePopover();\n        }\n        if (!popoverElement) {\n            throw \"unable to find or generate popover element\";\n        }\n        this.popoverElement = popoverElement;\n    };\n    /**\n     * Determines the correct dispatching element from a potential input\n     * @param dispatcher The event or element to get the dispatcher from\n     */\n    BasePopoverController.prototype.getDispatcher = function (dispatcher) {\n        if (dispatcher === void 0) { dispatcher = null; }\n        if (dispatcher instanceof Event) {\n            return dispatcher.target;\n        }\n        else if (dispatcher instanceof Element) {\n            return dispatcher;\n        }\n        else {\n            return this.element;\n        }\n    };\n    /**\n     * Schedules the popover to update on the next animation frame if visible\n     */\n    BasePopoverController.prototype.scheduleUpdate = function () {\n        if (this.popper && this.isVisible) {\n            void this.popper.update();\n        }\n    };\n    return BasePopoverController;\n}(Stacks.StacksController));\nexports.BasePopoverController = BasePopoverController;\nvar PopoverController = /** @class */ (function (_super) {\n    __extends(PopoverController, _super);\n    function PopoverController() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.popoverSelectorAttribute = \"aria-controls\";\n        return _this;\n    }\n    /**\n     * Toggles optional classes and accessibility attributes in addition to BasePopoverController.shown\n     */\n    PopoverController.prototype.shown = function (dispatcher) {\n        if (dispatcher === void 0) { dispatcher = null; }\n        this.toggleOptionalClasses(true);\n        this.toggleAccessibilityAttributes(true);\n        _super.prototype.shown.call(this, dispatcher);\n    };\n    /**\n     * Toggles optional classes and accessibility attributes in addition to BasePopoverController.hidden\n     */\n    PopoverController.prototype.hidden = function (dispatcher) {\n        if (dispatcher === void 0) { dispatcher = null; }\n        this.toggleOptionalClasses(false);\n        this.toggleAccessibilityAttributes(false);\n        _super.prototype.hidden.call(this, dispatcher);\n    };\n    /**\n     * Initializes accessibility attributes in addition to BasePopoverController.connect\n     */\n    PopoverController.prototype.connect = function () {\n        _super.prototype.connect.call(this);\n        this.toggleAccessibilityAttributes();\n    };\n    /**\n     * Binds global events to the document for hiding popovers on user interaction\n     */\n    PopoverController.prototype.bindDocumentEvents = function () {\n        this.boundHideOnOutsideClick = this.boundHideOnOutsideClick || this.hideOnOutsideClick.bind(this);\n        this.boundHideOnEscapePress = this.boundHideOnEscapePress || this.hideOnEscapePress.bind(this);\n        document.addEventListener(\"mousedown\", this.boundHideOnOutsideClick);\n        document.addEventListener(\"keyup\", this.boundHideOnEscapePress);\n    };\n    /**\n     * Unbinds global events to the document for hiding popovers on user interaction\n     */\n    PopoverController.prototype.unbindDocumentEvents = function () {\n        document.removeEventListener(\"mousedown\", this.boundHideOnOutsideClick);\n        document.removeEventListener(\"keyup\", this.boundHideOnEscapePress);\n    };\n    /**\n     * Forces the popover to hide if a user clicks outside of it or its reference element\n     * @param {Event} e - The document click event\n     */\n    PopoverController.prototype.hideOnOutsideClick = function (e) {\n        var target = e.target;\n        // check if the document was clicked inside either the reference element or the popover itself\n        // note: .contains also returns true if the node itself matches the target element\n        if (this.shouldHideOnOutsideClick && !this.referenceElement.contains(target) && !this.popoverElement.contains(target) && document.body.contains(target)) {\n            this.hide(e);\n        }\n    };\n    ;\n    /**\n     * Forces the popover to hide if the user presses escape while it, one of its childen, or the reference element are focused\n     * @param {Event} e - The document keyup event\n     */\n    PopoverController.prototype.hideOnEscapePress = function (e) {\n        // if the ESC key (27) wasn't pressed or if no popovers are showing, return\n        if (e.which !== 27 || !this.isVisible) {\n            return;\n        }\n        // check if the target was inside the popover element and refocus the triggering element\n        // note: .contains also returns true if the node itself matches the target element\n        if (this.popoverElement.contains(e.target)) {\n            this.referenceElement.focus();\n        }\n        this.hide(e);\n    };\n    ;\n    /**\n     * Toggles all classes on the originating element based on the `class-toggle` data\n     * @param {boolean=} show - A boolean indicating whether this is being triggered by a show or hide.\n     */\n    PopoverController.prototype.toggleOptionalClasses = function (show) {\n        if (!this.data.has(\"toggle-class\")) {\n            return;\n        }\n        var toggleClass = this.data.get(\"toggle-class\") || \"\";\n        var cl = this.referenceElement.classList;\n        toggleClass.split(/\\s+/).forEach(function (cls) {\n            cl.toggle(cls, show);\n        });\n    };\n    /**\n     * Toggles accessibility attributes based on whether the popover is shown or not\n     * @param {boolean=} show - A boolean indicating whether this is being triggered by a show or hide.\n     */\n    PopoverController.prototype.toggleAccessibilityAttributes = function (show) {\n        var expandedValue = (show === null || show === void 0 ? void 0 : show.toString()) || this.referenceElement.ariaExpanded || \"false\";\n        this.referenceElement.ariaExpanded = expandedValue;\n        this.referenceElement.setAttribute(\"aria-expanded\", expandedValue);\n    };\n    PopoverController.targets = [];\n    return PopoverController;\n}(BasePopoverController));\nexports.PopoverController = PopoverController;\n/**\n * Helper to manually show an s-popover element via external JS\n * @param element the element the `data-controller=\"s-popover\"` attribute is on\n */\nfunction showPopover(element) {\n    var _a = getPopover(element), isPopover = _a.isPopover, controller = _a.controller;\n    if (controller) {\n        controller.show();\n    }\n    else if (isPopover) {\n        element.setAttribute(\"data-s-popover-auto-show\", \"true\");\n    }\n    else {\n        throw \"element does not have data-controller=\\\"s-popover\\\"\";\n    }\n}\nexports.showPopover = showPopover;\n/**\n * Helper to manually hide an s-popover element via external JS\n * @param element the element the `data-controller=\"s-popover\"` attribute is on\n */\nfunction hidePopover(element) {\n    var _a = getPopover(element), isPopover = _a.isPopover, controller = _a.controller, popover = _a.popover;\n    if (controller) {\n        controller.hide();\n    }\n    else if (isPopover) {\n        element.removeAttribute(\"data-s-popover-auto-show\");\n        if (popover) {\n            popover.classList.remove(\"is-visible\");\n        }\n    }\n    else {\n        throw \"element does not have data-controller=\\\"s-popover\\\"\";\n    }\n}\nexports.hidePopover = hidePopover;\n/**\n * Attaches a popover to an element and performs additional configuration.\n * @param element the element that will receive the `data-controller=\"s-popover\"` attribute.\n * @param popover an element with the `.s-popover` class or HTML string containing a single element with the `.s-popover` class.\n *                If the popover does not have a parent element, it will be inserted as a immediately after the reference element.\n * @param options an optional collection of options to use when configuring the popover.\n */\nfunction attachPopover(element, popover, options) {\n    var _a = getPopover(element), referenceElement = _a.referenceElement, existingPopover = _a.popover;\n    if (existingPopover) {\n        throw \"element already has popover with id=\\\"\".concat(existingPopover.id, \"\\\"\");\n    }\n    if (!referenceElement) {\n        throw \"element has invalid data-s-popover-reference-selector attribute\";\n    }\n    if (typeof popover === 'string') {\n        // eslint-disable-next-line no-unsanitized/method\n        var elements = document.createRange().createContextualFragment(popover).children;\n        if (elements.length !== 1) {\n            throw \"popover should contain a single element\";\n        }\n        popover = elements[0];\n    }\n    var existingId = referenceElement.getAttribute(\"aria-controls\");\n    var popoverId = popover.id;\n    if (!popover.classList.contains('s-popover')) {\n        throw \"popover should have the \\\"s-popover\\\" class but had class=\\\"\".concat(popover.className, \"\\\"\");\n    }\n    if (existingId && existingId !== popoverId) {\n        throw \"element has aria-controls=\\\"\".concat(existingId, \"\\\" but popover has id=\\\"\").concat(popoverId, \"\\\"\");\n    }\n    if (!popoverId) {\n        popoverId = \"--stacks-s-popover-\" + Math.random().toString(36).substring(2, 10);\n        popover.id = popoverId;\n    }\n    if (!existingId) {\n        referenceElement.setAttribute(\"aria-controls\", popoverId);\n    }\n    if (!popover.parentElement && element.parentElement) {\n        referenceElement.insertAdjacentElement(\"afterend\", popover);\n    }\n    toggleController(element, \"s-popover\", true);\n    if (options) {\n        if (options.toggleOnClick) {\n            referenceElement.setAttribute(\"data-action\", \"click->s-popover#toggle\");\n        }\n        if (options.placement) {\n            element.setAttribute(\"data-s-popover-placement\", options.placement);\n        }\n        if (options.autoShow) {\n            element.setAttribute(\"data-s-popover-auto-show\", \"true\");\n        }\n    }\n}\nexports.attachPopover = attachPopover;\n/**\n * Removes the popover controller from an element and removes the popover from the DOM.\n * @param element the element that has the `data-controller=\"s-popover\"` attribute.\n * @returns The popover that was attached to the element.\n */\nfunction detachPopover(element) {\n    var _a = getPopover(element), isPopover = _a.isPopover, controller = _a.controller, referenceElement = _a.referenceElement, popover = _a.popover;\n    // Hide the popover so its events fire.\n    controller === null || controller === void 0 ? void 0 : controller.hide();\n    // Remove the popover if it exists\n    popover === null || popover === void 0 ? void 0 : popover.remove();\n    // Remove the popover controller and the aria-controls attributes.\n    if (isPopover) {\n        toggleController(element, \"s-popover\", false);\n        if (referenceElement) {\n            referenceElement.removeAttribute(\"aria-controls\");\n        }\n    }\n    return popover;\n}\nexports.detachPopover = detachPopover;\n/**\n * Gets the current state of an element that may be or is intended to be an s-popover controller\n * so it can be configured either directly or via the DOM.\n * @param element An element that may have `data-controller=\"s-popover\"`.\n */\nfunction getPopover(element) {\n    var _a;\n    var isPopover = ((_a = element.getAttribute(\"data-controller\")) === null || _a === void 0 ? void 0 : _a.includes(\"s-popover\")) || false;\n    var controller = Stacks.application.getControllerForElementAndIdentifier(element, \"s-popover\");\n    var referenceSelector = element.getAttribute(\"data-s-popover-reference-selector\");\n    var referenceElement = referenceSelector ? element.querySelector(referenceSelector) : element;\n    var popoverId = referenceElement ? referenceElement.getAttribute(\"aria-controls\") : null;\n    var popover = popoverId ? document.getElementById(popoverId) : null;\n    return { isPopover: isPopover, controller: controller, referenceElement: referenceElement, popover: popover };\n}\n/**\n * Adds or removes the controller from an element's [data-controller] attribute without altering existing entries\n * @param el The element to alter\n * @param controllerName The name of the controller to add/remove\n * @param include Whether to add the controllerName value\n */\nfunction toggleController(el, controllerName, include) {\n    var _a;\n    var controllers = new Set((_a = el.getAttribute('data-controller')) === null || _a === void 0 ? void 0 : _a.split(/\\s+/));\n    if (include) {\n        controllers.add(controllerName);\n    }\n    else {\n        controllers.delete(controllerName);\n    }\n    el.setAttribute('data-controller', Array.from(controllers).join(' '));\n}\n\n\n/***/ }),\n\n/***/ 753:\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_209054__) {\n\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TableController = void 0;\nvar Stacks = __nested_webpack_require_209054__(36);\nvar TableController = /** @class */ (function (_super) {\n    __extends(TableController, _super);\n    function TableController() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TableController.prototype.setCurrentSort = function (headElem, direction) {\n        if ([\"asc\", \"desc\", \"none\"].indexOf(direction) < 0) {\n            throw \"direction must be one of asc, desc, or none\";\n        }\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        var controller = this;\n        this.columnTargets.forEach(function (target) {\n            var isCurrrent = target === headElem;\n            target.classList.toggle(\"is-sorted\", isCurrrent && direction !== \"none\");\n            target.querySelectorAll(\".js-sorting-indicator\").forEach(function (icon) {\n                var visible = isCurrrent ? direction : \"none\";\n                icon.classList.toggle(\"d-none\", !icon.classList.contains(\"js-sorting-indicator-\" + visible));\n            });\n            if (!isCurrrent || direction === \"none\") {\n                controller.removeElementData(target, \"sort-direction\");\n            }\n            else {\n                controller.setElementData(target, \"sort-direction\", direction);\n            }\n        });\n    };\n    ;\n    TableController.prototype.sort = function (evt) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        var controller = this;\n        var colHead = evt.currentTarget;\n        if (!(colHead instanceof HTMLTableCellElement)) {\n            throw \"invalid event target\";\n        }\n        var table = this.element;\n        var tbody = table.tBodies[0];\n        // the column slot number of the clicked header\n        var colno = getCellSlot(colHead);\n        if (colno < 0) { // this shouldn't happen if the clicked element is actually a column head\n            return;\n        }\n        // an index of the <tbody>, so we can find out for each row which <td> element is\n        // in the same column slot as the header\n        var slotIndex = buildIndex(tbody);\n        // the default behavior when clicking a header is to sort by this column in ascending\n        // direction, *unless* it is already sorted that way\n        var direction = this.getElementData(colHead, \"sort-direction\") === \"asc\" ? -1 : 1;\n        var rows = Array.from(table.tBodies[0].rows);\n        // if this is still false after traversing the data, that means all values are integers (or empty)\n        // and thus we'll sort numerically.\n        var anyNonInt = false;\n        // data will be a list of tuples [value, rowNum], where value is what we're sorting by\n        var data = [];\n        var firstBottomRow;\n        rows.forEach(function (row, index) {\n            var force = controller.getElementData(row, \"sort-to\");\n            if (force === \"top\") {\n                return; // rows not added to the list will automatically end up at the top\n            }\n            else if (force === \"bottom\") {\n                if (!firstBottomRow) {\n                    firstBottomRow = row;\n                }\n                return;\n            }\n            var cell = slotIndex[index][colno];\n            if (!cell) {\n                data.push([\"\", index]);\n                return;\n            }\n            // unless the to-be-sorted-by value is explicitly provided on the element via this attribute,\n            // the value we're using is the cell's text, trimmed of any whitespace\n            var explicit = controller.getElementData(cell, \"sort-val\");\n            var d = typeof explicit === \"string\" ? explicit : cell.textContent.trim();\n            if ((d !== \"\") && (\"\".concat(parseInt(d, 10)) !== d)) {\n                anyNonInt = true;\n            }\n            data.push([d, index]);\n        });\n        // If all values were integers (or empty cells), sort numerically, with empty cells treated as\n        // having the lowest possible value (i.e. sorted to the top if ascending, bottom if descending)\n        if (!anyNonInt) {\n            data.forEach(function (tuple) {\n                tuple[0] = tuple[0] === \"\" ? Number.MIN_VALUE : parseInt(tuple[0], 10);\n            });\n        }\n        // We don't sort an array of <tr>, but instead an arrays of row *numbers*, because this way we\n        // can enforce stable sorting, i.e. rows that compare equal are guaranteed to remain in the same\n        // order (the JS standard does not gurantee this for sort()).\n        data.sort(function (a, b) {\n            // first compare the values (a[0])\n            if (a[0] > b[0]) {\n                return 1 * direction;\n            }\n            else if (a[0] < b[0]) {\n                return -1 * direction;\n            }\n            else {\n                // if the values are equal, compare the row numbers (a[1]) to guarantee stable sorting\n                // (note that this comparison is independent of the sorting direction)\n                return a[1] > b[1] ? 1 : -1;\n            }\n        });\n        // this is the actual reordering of the table rows\n        data.forEach(function (tup) {\n            var row = rows[tup[1]];\n            row.parentElement.removeChild(row);\n            if (firstBottomRow) {\n                tbody.insertBefore(row, firstBottomRow);\n            }\n            else {\n                tbody.appendChild(row);\n            }\n        });\n        // update the UI and set the `data-sort-direction` attribute if appropriate, so that the next click\n        // will cause sorting in descending direction\n        this.setCurrentSort(colHead, direction === 1 ? \"asc\" : \"desc\");\n    };\n    TableController.targets = [\"column\"];\n    return TableController;\n}(Stacks.StacksController));\nexports.TableController = TableController;\nfunction buildIndex(section) {\n    var result = buildIndexOrGetCellSlot(section);\n    if (!(result instanceof Array)) {\n        throw \"shouldn't happen\";\n    }\n    return result;\n}\nfunction getCellSlot(cell) {\n    if (!(cell.parentElement && cell.parentElement.parentElement instanceof HTMLTableSectionElement)) {\n        throw \"invalid table\";\n    }\n    var result = buildIndexOrGetCellSlot(cell.parentElement.parentElement, cell);\n    if (typeof result !== \"number\") {\n        throw \"shouldn't happen\";\n    }\n    return result;\n}\n// Just because a <td> is the 4th *child* of its <tr> doesn't mean it belongs to the 4th *column*\n// of the table. Previous cells may have a colspan; cells in previous rows may have a rowspan.\n// Because we need to know which header cells and data cells belong together, we have to 1) find out\n// which column number (or \"slot\" as we call it here) the header cell has, and 2) for each row find\n// out which <td> cell corresponds to this slot (because those are the rows we're sorting by).\n//\n// That's what the following function does. If the second argument is not given, it returns an index\n// of the table, which is an array of arrays. Each of the sub-arrays corresponds to a table row. The\n// indices of the sub-array correspond to column slots; the values are the actual table cell elements.\n// For example index[4][3] is the <td> or <th> in row 4, column 3 of the table section (<tbody> or <thead>).\n// Note that this element is not necessarily even in the 4th (zero-based) <tr> -- if it has a rowSpan > 1,\n// it may also be in a previous <tr>.\n//\n// If the second argument is given, it's a <td> or <th> that we're trying to find, and the algorithm\n// stops as soon as it has found it and the function returns its slot number.\nfunction buildIndexOrGetCellSlot(section, findCell) {\n    var index = [];\n    var curRow = section.children[0];\n    // the elements of these two arrays are synchronized; the first array contains table cell elements,\n    // the second one contains a number that indicates for how many more rows this elements will\n    // exist (i.e. the value is initially one less than the cell's rowspan, and will be decreased for each row)\n    var growing = [];\n    var growingRowsLeft = [];\n    // continue while we have actual <tr>'s left *or* we still have rowspan'ed elements that aren't done\n    while (curRow || growingRowsLeft.some(function (e) { return e !== 0; })) {\n        var curIndexRow = [];\n        index.push(curIndexRow);\n        var curSlot = 0;\n        if (curRow) {\n            for (var curCellInd = 0; curCellInd < curRow.children.length; curCellInd++) {\n                while (growingRowsLeft[curSlot]) {\n                    growingRowsLeft[curSlot]--;\n                    curIndexRow[curSlot] = growing[curSlot];\n                    curSlot++;\n                }\n                var cell = curRow.children[curCellInd];\n                if (!(cell instanceof HTMLTableCellElement)) {\n                    throw \"invalid table\";\n                }\n                if (getComputedStyle(cell).display === \"none\") {\n                    continue;\n                }\n                if (cell === findCell) {\n                    return curSlot;\n                }\n                var nextFreeSlot = curSlot + cell.colSpan;\n                for (; curSlot < nextFreeSlot; curSlot++) {\n                    growingRowsLeft[curSlot] = cell.rowSpan - 1; // if any of these is already growing, the table is broken -- no guarantees of anything\n                    growing[curSlot] = cell;\n                    curIndexRow[curSlot] = cell;\n                }\n            }\n        }\n        while (curSlot < growing.length) {\n            if (growingRowsLeft[curSlot]) {\n                growingRowsLeft[curSlot]--;\n                curIndexRow[curSlot] = growing[curSlot];\n            }\n            curSlot++;\n        }\n        if (curRow) {\n            curRow = curRow.nextElementSibling;\n        }\n    }\n    return findCell ? -1 : index; /* if findCell was given but we end up here, that means it isn't in this section */\n}\n\n\n/***/ }),\n\n/***/ 355:\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_219863__) {\n\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setTooltipText = exports.setTooltipHtml = exports.TooltipController = void 0;\nvar Stacks = __nested_webpack_require_219863__(36);\nvar s_popover_1 = __nested_webpack_require_219863__(388);\nvar TooltipController = /** @class */ (function (_super) {\n    __extends(TooltipController, _super);\n    function TooltipController() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.popoverSelectorAttribute = \"aria-describedby\";\n        return _this;\n    }\n    /**\n     * Binds mouseover and mouseout events in addition to BasePopoverController.connect\n     */\n    TooltipController.prototype.connect = function () {\n        _super.prototype.connect.call(this);\n        // Only bind to mouse events if the pointer device supports hover behavior.\n        // Otherwise we run into issues with mobile browser showing popovers for\n        // click events and not being able to hide them.\n        if (window.matchMedia(\"(hover: hover)\").matches) {\n            this.bindMouseEvents();\n        }\n        this.bindKeyboardEvents();\n    };\n    /**\n     * Unbinds mouse events in addition to BasePopoverController.disconnect\n     */\n    TooltipController.prototype.disconnect = function () {\n        this.unbindKeyboardEvents();\n        this.unbindMouseEvents();\n        _super.prototype.disconnect.call(this);\n    };\n    /**\n     * Attempts to show the tooltip popover so long as no other Stacks-managed popover is\n     * present on the page.\n     */\n    TooltipController.prototype.show = function (dispatcher) {\n        if (dispatcher === void 0) { dispatcher = null; }\n        // check and see if this controller coexists with a popover\n        var controller = Stacks.application.getControllerForElementAndIdentifier(this.element, \"s-popover\");\n        // if the controller exists and already has a visible popover, don't show the tooltip\n        if (controller && controller.isVisible) {\n            return;\n        }\n        _super.prototype.show.call(this, dispatcher);\n    };\n    /**\n     * Sets up a tooltip popover show after a delay.\n     */\n    TooltipController.prototype.scheduleShow = function (dispatcher) {\n        var _this = this;\n        if (dispatcher === void 0) { dispatcher = null; }\n        window.clearTimeout(this.activeTimeout);\n        this.activeTimeout = window.setTimeout(function () { return _this.show(dispatcher); }, 300);\n    };\n    /**\n     * Cancels the scheduled tooltip popover display and hides it if already displayed\n     */\n    TooltipController.prototype.scheduleHide = function (dispatcher) {\n        var _this = this;\n        if (dispatcher === void 0) { dispatcher = null; }\n        window.clearTimeout(this.activeTimeout);\n        this.activeTimeout = window.setTimeout(function () { return _super.prototype.hide.call(_this, dispatcher); }, 100);\n    };\n    /**\n     * Cancels the activeTimeout\n     */\n    TooltipController.prototype.clearActiveTimeout = function () {\n        clearTimeout(this.activeTimeout);\n    };\n    /**\n     * Applies data-s-tooltip-html-title and title attributes.\n     */\n    TooltipController.prototype.applyTitleAttributes = function () {\n        var content;\n        var htmlTitle = this.data.get(\"html-title\");\n        if (htmlTitle) {\n            // eslint-disable-next-line no-unsanitized/method\n            content = document.createRange().createContextualFragment(htmlTitle);\n        }\n        else {\n            var plainTitle = this.element.getAttribute(\"title\");\n            if (plainTitle) {\n                content = document.createTextNode(plainTitle);\n            }\n            else {\n                return null;\n            }\n        }\n        this.data.delete(\"html-title\");\n        this.element.removeAttribute(\"title\");\n        var popoverId = this.element.getAttribute(\"aria-describedby\");\n        if (!popoverId) {\n            popoverId = TooltipController.generateId();\n            this.element.setAttribute(\"aria-describedby\", popoverId);\n        }\n        var popover = document.getElementById(popoverId);\n        if (!popover) {\n            popover = document.createElement(\"div\");\n            popover.id = popoverId;\n            popover.className = \"s-popover s-popover__tooltip\";\n            popover.setAttribute(\"role\", \"tooltip\");\n            var parentNode = this.element.parentNode;\n            if (parentNode) {\n                // insertBefore inserts at end if element.nextSibling is null.\n                parentNode.insertBefore(popover, this.element.nextSibling);\n            }\n            else {\n                document.body.appendChild(popover);\n            }\n        }\n        var arrow = popover.querySelector(\".s-popover--arrow\");\n        // clear and set the content of the popover\n        popover.innerHTML = \"\";\n        popover.appendChild(content);\n        // create the arrow if necessary\n        if (arrow) {\n            popover.appendChild(arrow);\n        }\n        else {\n            popover.insertAdjacentHTML(\"beforeend\", \"<div class=\\\"s-popover--arrow\\\"></div>\");\n        }\n        this.scheduleUpdate();\n        return popover;\n    };\n    /**\n     * Automatically hides the tooltip popover when a Stacks popover is shown anywhere on\n     * the page.\n     */\n    TooltipController.prototype.bindDocumentEvents = function () {\n        this.boundHideIfWithin = this.boundHideIfWithin || this.hideIfWithin.bind(this);\n        document.addEventListener(\"s-popover:shown\", this.boundHideIfWithin);\n    };\n    /**\n     * Unbinds all mouse events\n     */\n    TooltipController.prototype.unbindDocumentEvents = function () {\n        document.removeEventListener(\"s-popover:shown\", this.boundHideIfWithin);\n    };\n    /**\n     * Attempts to generate a new tooltip popover from the title attribute if no popover\n     * was present when requested, otherwise throws an error.\n     */\n    TooltipController.prototype.generatePopover = function () {\n        return this.applyTitleAttributes();\n    };\n    /**\n     * Hides the tooltip if is or is within the event's target.\n     * @param event An event object from s-popover:shown\n     */\n    TooltipController.prototype.hideIfWithin = function (event) {\n        if (event.target.contains(this.referenceElement)) {\n            this.scheduleHide();\n        }\n    };\n    TooltipController.prototype.hideOnEscapeKeyEvent = function (event) {\n        if (event.key === \"Escape\") {\n            this.scheduleHide();\n        }\n    };\n    /**\n     * Binds mouse events to show/hide on reference element hover\n     */\n    TooltipController.prototype.bindKeyboardEvents = function () {\n        this.boundScheduleShow = this.boundScheduleShow || this.scheduleShow.bind(this);\n        this.boundHide = this.boundHide || this.scheduleHide.bind(this);\n        this.boundHideOnEscapeKeyEvent = this.boundHideOnEscapeKeyEvent || this.hideOnEscapeKeyEvent.bind(this);\n        this.referenceElement.addEventListener(\"focus\", this.boundScheduleShow);\n        this.referenceElement.addEventListener(\"blur\", this.boundHide);\n        document.addEventListener(\"keyup\", this.boundHideOnEscapeKeyEvent);\n    };\n    /**\n     * Unbinds all mouse events\n     */\n    TooltipController.prototype.unbindKeyboardEvents = function () {\n        this.referenceElement.removeEventListener(\"focus\", this.boundScheduleShow);\n        this.referenceElement.removeEventListener(\"blur\", this.boundHide);\n        document.removeEventListener(\"keyup\", this.boundHideOnEscapeKeyEvent);\n    };\n    /**\n     * Binds mouse events to show/hide on reference element hover\n     */\n    TooltipController.prototype.bindMouseEvents = function () {\n        this.boundScheduleShow = this.boundScheduleShow || this.scheduleShow.bind(this);\n        this.boundHide = this.boundHide || this.scheduleHide.bind(this);\n        this.boundClearActiveTimeout = this.boundClearActiveTimeout || this.clearActiveTimeout.bind(this);\n        this.referenceElement.addEventListener(\"mouseover\", this.boundScheduleShow);\n        this.referenceElement.addEventListener(\"mouseout\", this.boundHide);\n        this.popoverElement.addEventListener(\"mouseover\", this.boundClearActiveTimeout);\n        this.popoverElement.addEventListener(\"mouseout\", this.boundHide);\n    };\n    /**\n     * Unbinds all mouse events\n     */\n    TooltipController.prototype.unbindMouseEvents = function () {\n        this.referenceElement.removeEventListener(\"mouseover\", this.boundScheduleShow);\n        this.referenceElement.removeEventListener(\"mouseout\", this.boundHide);\n        this.referenceElement.removeEventListener(\"focus\", this.boundScheduleShow);\n        this.referenceElement.removeEventListener(\"blur\", this.boundHide);\n        this.popoverElement.removeEventListener(\"mouseover\", this.boundClearActiveTimeout);\n        this.popoverElement.removeEventListener(\"mouseout\", this.boundHide);\n    };\n    /**\n     * Generates an ID for tooltips created with setTooltip.\n     */\n    TooltipController.generateId = function () {\n        // generate a random number, then convert to a well formatted string\n        return \"--stacks-s-tooltip-\" + Math.random().toString(36).substring(2, 10);\n    };\n    TooltipController.targets = [];\n    return TooltipController;\n}(s_popover_1.BasePopoverController));\nexports.TooltipController = TooltipController;\n/**\n * Adds or updates a Stacks tooltip on a given element, initializing the controller if necessary\n * @param element The element to add a tooltip to.\n * @param html An HTML string to populate the tooltip with.\n * @param options Options for rendering the tooltip.\n */\nfunction setTooltipHtml(element, html, options) {\n    element.setAttribute(\"data-s-tooltip-html-title\", html);\n    element.removeAttribute(\"title\");\n    applyOptionsAndTitleAttributes(element, options);\n}\nexports.setTooltipHtml = setTooltipHtml;\n/**\n * Adds or updates a Stacks tooltip on a given element, initializing the controller if necessary\n * @param element The element to add a tooltip to.\n * @param text A plain text string to populate the tooltip with.\n * @param options Options for rendering the tooltip.\n */\nfunction setTooltipText(element, text, options) {\n    element.setAttribute(\"title\", text);\n    element.removeAttribute(\"data-s-tooltip-html-title\");\n    applyOptionsAndTitleAttributes(element, options);\n}\nexports.setTooltipText = setTooltipText;\n/**\n * Shared helper for setTooltip* to initialize and set tooltip content\n * @param element The element to add a tooltip to.\n * @param options Options for rendering the tooltip.\n */\nfunction applyOptionsAndTitleAttributes(element, options) {\n    if (options && options.placement) {\n        element.setAttribute(\"data-s-tooltip-placement\", options.placement);\n    }\n    var controller = Stacks.application.getControllerForElementAndIdentifier(element, \"s-tooltip\");\n    if (controller) {\n        controller.applyTitleAttributes();\n    }\n    else {\n        var dataController = element.getAttribute(\"data-controller\");\n        element.setAttribute(\"data-controller\", \"\".concat(dataController ? dataController : \"\", \" s-tooltip\"));\n    }\n}\n\n\n/***/ }),\n\n/***/ 637:\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_231788__) {\n\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UploaderController = void 0;\nvar Stacks = __nested_webpack_require_231788__(36);\n;\nvar UploaderController = /** @class */ (function (_super) {\n    __extends(UploaderController, _super);\n    function UploaderController() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    UploaderController.prototype.connect = function () {\n        _super.prototype.connect.call(this);\n        this.boundDragEnter = this.handleUploaderActive.bind(this, true);\n        this.boundDragLeave = this.handleUploaderActive.bind(this, false);\n        this.inputTarget.addEventListener(\"dragenter\", this.boundDragEnter);\n        this.inputTarget.addEventListener(\"dragleave\", this.boundDragLeave);\n    };\n    UploaderController.prototype.disconnect = function () {\n        this.inputTarget.removeEventListener(\"dragenter\", this.boundDragEnter);\n        this.inputTarget.removeEventListener(\"dragleave\", this.boundDragLeave);\n        _super.prototype.disconnect.call(this);\n    };\n    /**\n     * Handles rendering the file preview state on input change\n     */\n    UploaderController.prototype.handleInput = function () {\n        var _this = this;\n        this.previewsTarget.innerHTML = \"\";\n        if (!this.inputTarget.files) {\n            return;\n        }\n        var count = this.inputTarget.files.length;\n        this.getDataURLs(this.inputTarget.files, UploaderController.FILE_DISPLAY_LIMIT)\n            .then(function (res) {\n            _this.handleVisible(true);\n            var hasMultipleFiles = res.length > 1;\n            if (hasMultipleFiles) {\n                var headingElement = document.createElement(\"div\");\n                headingElement.classList.add(\"s-uploader--previews-heading\");\n                headingElement.innerText = res.length < count ?\n                    \"Showing \".concat(res.length, \" of \").concat(count, \" files\") : \"\".concat(count, \" items\");\n                _this.previewsTarget.appendChild(headingElement);\n                _this.previewsTarget.classList.add(\"has-multiple\");\n            }\n            else {\n                _this.previewsTarget.classList.remove(\"has-multiple\");\n            }\n            res.forEach(function (file) { return _this.addFilePreview(file); });\n            _this.handleUploaderActive(true);\n        })\n            // TODO consider rendering an error message\n            .catch(function () { return null; });\n    };\n    /**\n     * Resets the Uploader to initial state\n     */\n    UploaderController.prototype.reset = function () {\n        this.inputTarget.value = '';\n        this.previewsTarget.innerHTML = \"\";\n        this.handleVisible(false);\n    };\n    /**\n     * Set hide/show and disabled state on elements depending on preview state\n     * @param  {boolean} shouldPreview - Uploader is entering a preview state\n     */\n    UploaderController.prototype.handleVisible = function (shouldPreview) {\n        var scope = this.targets.scope;\n        var hideElements = scope.findAllElements('[data-s-uploader-hide-on-input]');\n        var showElements = scope.findAllElements('[data-s-uploader-show-on-input]');\n        var enableElements = scope.findAllElements('[data-s-uploader-enable-on-input]');\n        if (shouldPreview) {\n            hideElements.forEach(function (el) {\n                el.classList.add(\"d-none\");\n            });\n            showElements.forEach(function (el) {\n                el.classList.remove(\"d-none\");\n            });\n            enableElements.forEach(function (el) {\n                el.removeAttribute(\"disabled\");\n            });\n        }\n        else {\n            hideElements.forEach(function (el) {\n                el.classList.remove(\"d-none\");\n            });\n            showElements.forEach(function (el) {\n                el.classList.add(\"d-none\");\n            });\n            enableElements.forEach(function (el) {\n                el.setAttribute(\"disabled\", \"true\");\n            });\n            this.handleUploaderActive(false);\n        }\n    };\n    /**\n     * Adds a DOM element to preview a selected file\n     * @param  {FilePreview} file\n     */\n    UploaderController.prototype.addFilePreview = function (file) {\n        if (!file) {\n            return;\n        }\n        var previewElement = document.createElement(\"div\");\n        var thumbElement;\n        if (file.type.match('image/*') && file.data) {\n            thumbElement = document.createElement(\"img\");\n            thumbElement.src = file.data.toString();\n            thumbElement.alt = file.name;\n        }\n        else {\n            thumbElement = document.createElement(\"div\");\n            thumbElement.innerText = file.name;\n        }\n        thumbElement.classList.add(\"s-uploader--preview-thumbnail\");\n        previewElement.appendChild(thumbElement);\n        previewElement.classList.add(\"s-uploader--preview\");\n        previewElement.setAttribute('data-filename', file.name);\n        this.previewsTarget.appendChild(previewElement);\n    };\n    /**\n     * Toggles display and disabled state for select elements on valid input\n     * @param  {boolean} active - Uploader is in active state (typically on 'dragenter')\n     */\n    UploaderController.prototype.handleUploaderActive = function (active) {\n        this.uploaderTarget.classList.toggle(\"is-active\", active);\n    };\n    /**\n     * Converts the file data into a data URL\n     * @param  {File} file\n     * @returns an object containing a FilePreview object\n     */\n    UploaderController.prototype.fileToDataURL = function (file) {\n        var reader = new FileReader();\n        var name = file.name, size = file.size, type = file.type;\n        if (size < UploaderController.MAX_FILE_SIZE && type.indexOf(\"image\") > -1) {\n            return new Promise(function (resolve, reject) {\n                reader.onload = function (evt) {\n                    var _a;\n                    var res = (_a = evt === null || evt === void 0 ? void 0 : evt.target) === null || _a === void 0 ? void 0 : _a.result;\n                    if (res) {\n                        resolve({ data: res, name: name, type: type });\n                    }\n                    else {\n                        reject();\n                    }\n                };\n                reader.readAsDataURL(file);\n            });\n        }\n        else {\n            return Promise.resolve({ name: name, type: type });\n        }\n    };\n    /**\n     * Gets an array of FilePreviews from a FileList\n     * @param  {FileList|[]} files\n     * @returns an array of FilePreview objects from a FileList\n     */\n    UploaderController.prototype.getDataURLs = function (files, limit) {\n        var _this = this;\n        var promises = Array.from(files)\n            .slice(0, Math.min(limit, files.length))\n            .map(function (f) { return _this.fileToDataURL(f); });\n        return Promise.all(promises);\n    };\n    UploaderController.targets = [\"input\", \"previews\", \"uploader\"];\n    UploaderController.FILE_DISPLAY_LIMIT = 10;\n    UploaderController.MAX_FILE_SIZE = 1024 * 1024 * 10; // 10 MB\n    return UploaderController;\n}(Stacks.StacksController));\nexports.UploaderController = UploaderController;\n;\n\n\n/***/ }),\n\n/***/ 603:\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_239818__) {\n\n\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__nested_webpack_require_239818__(708);\nvar controllers_1 = __nested_webpack_require_239818__(470);\nvar stacks_1 = __nested_webpack_require_239818__(36);\n// register all built-in controllers\nstacks_1.application.register(\"s-expandable-control\", controllers_1.ExpandableController);\nstacks_1.application.register(\"s-modal\", controllers_1.ModalController);\nstacks_1.application.register(\"s-navigation-tablist\", controllers_1.TabListController);\nstacks_1.application.register(\"s-popover\", controllers_1.PopoverController);\nstacks_1.application.register(\"s-table\", controllers_1.TableController);\nstacks_1.application.register(\"s-tooltip\", controllers_1.TooltipController);\nstacks_1.application.register(\"s-uploader\", controllers_1.UploaderController);\n// finalize the application to guard our controller namespace\nstacks_1.StacksApplication.finalize();\n// export all controllers w/ helpers\n__exportStar(__nested_webpack_require_239818__(470), exports);\n// export the entirety of the contents of stacks.ts\n__exportStar(__nested_webpack_require_239818__(36), exports);\n\n\n/***/ }),\n\n/***/ 36:\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_241655__) {\n\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.addController = exports.createController = exports.StacksController = exports.application = exports.StacksApplication = void 0;\nvar Stimulus = __nested_webpack_require_241655__(931);\nvar StacksApplication = /** @class */ (function (_super) {\n    __extends(StacksApplication, _super);\n    function StacksApplication() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    StacksApplication.prototype.load = function (head) {\n        var rest = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            rest[_i - 1] = arguments[_i];\n        }\n        var definitions = Array.isArray(head) ? head : __spreadArray([head], rest, true);\n        for (var _a = 0, definitions_1 = definitions; _a < definitions_1.length; _a++) {\n            var definition = definitions_1[_a];\n            var hasPrefix = /^s-/.test(definition.identifier);\n            if (StacksApplication._initializing && !hasPrefix) {\n                throw \"Stacks-created Stimulus controller names must start with \\\"s-\\\".\";\n            }\n            if (!StacksApplication._initializing && hasPrefix) {\n                throw \"The \\\"s-\\\" prefix on Stimulus controller names is reserved for Stacks-created controllers.\";\n            }\n        }\n        _super.prototype.load.call(this, definitions);\n    };\n    StacksApplication.start = function (element, schema) {\n        var application = new StacksApplication(element, schema);\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        application.start();\n        return application;\n    };\n    StacksApplication.finalize = function () {\n        StacksApplication._initializing = false;\n    };\n    StacksApplication._initializing = true;\n    return StacksApplication;\n}(Stimulus.Application));\nexports.StacksApplication = StacksApplication;\nexports.application = StacksApplication.start();\nvar StacksController = /** @class */ (function (_super) {\n    __extends(StacksController, _super);\n    function StacksController() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    StacksController.prototype.getElementData = function (element, key) {\n        return element.getAttribute(\"data-\" + this.identifier + \"-\" + key);\n    };\n    ;\n    StacksController.prototype.setElementData = function (element, key, value) {\n        element.setAttribute(\"data-\" + this.identifier + \"-\" + key, value);\n    };\n    ;\n    StacksController.prototype.removeElementData = function (element, key) {\n        element.removeAttribute(\"data-\" + this.identifier + \"-\" + key);\n    };\n    ;\n    StacksController.prototype.triggerEvent = function (eventName, detail, optionalElement) {\n        var namespacedName = this.identifier + \":\" + eventName;\n        var event;\n        try {\n            event = new CustomEvent(namespacedName, { bubbles: true, cancelable: true, detail: detail });\n        }\n        catch (ex) {\n            // Internet Explorer\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            event = document.createEvent(\"CustomEvent\");\n            event.initCustomEvent(namespacedName, true, true, detail);\n        }\n        (optionalElement || this.element).dispatchEvent(event);\n        return event;\n    };\n    ;\n    return StacksController;\n}(Stimulus.Controller));\nexports.StacksController = StacksController;\nfunction createController(controllerDefinition) {\n    var _a;\n    // eslint-disable-next-line no-prototype-builtins\n    var Controller = controllerDefinition.hasOwnProperty(\"targets\")\n        ? (_a = /** @class */ (function (_super) {\n                __extends(Controller, _super);\n                function Controller() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                return Controller;\n            }(StacksController)),\n            _a.targets = controllerDefinition.targets,\n            _a) : /** @class */ (function (_super) {\n        __extends(Controller, _super);\n        function Controller() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        return Controller;\n    }(StacksController));\n    for (var prop in controllerDefinition) {\n        // eslint-disable-next-line no-prototype-builtins\n        if (prop !== \"targets\" && controllerDefinition.hasOwnProperty(prop)) {\n            Object.defineProperty(Controller.prototype, prop, Object.getOwnPropertyDescriptor(controllerDefinition, prop));\n        }\n    }\n    return Controller;\n}\nexports.createController = createController;\nfunction addController(name, controller) {\n    exports.application.register(name, createController(controller));\n}\nexports.addController = addController;\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_247833__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_247833__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t(() => {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__nested_webpack_require_247833__.d = (exports, definition) => {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__nested_webpack_require_247833__.o(definition, key) && !__nested_webpack_require_247833__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t(() => {\n/******/ \t\t__nested_webpack_require_247833__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/make namespace object */\n/******/ \t(() => {\n/******/ \t\t// define __esModule on exports\n/******/ \t\t__nested_webpack_require_247833__.r = (exports) => {\n/******/ \t\t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t\t}\n/******/ \t\t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \tvar __webpack_exports__ = __nested_webpack_require_247833__(603);\n/******/ \t\n/******/ \treturn __webpack_exports__;\n/******/ })()\n;\n});\n\n//# sourceURL=webpack:///./node_modules/@stackoverflow/stacks/dist/js/stacks.js?");

/***/ }),

/***/ "./less/site.less":
/*!************************!*\
  !*** ./less/site.less ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack:///./less/site.less?");

/***/ }),

/***/ "./ts/src/site.ts":
/*!************************!*\
  !*** ./ts/src/site.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nexports.__esModule = true;\n__webpack_require__(/*! @stackoverflow/stacks */ \"./node_modules/@stackoverflow/stacks/dist/js/stacks.js\");\n__webpack_require__(/*! ../../less/site.less */ \"./less/site.less\");\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n    console.log('hello world! <3');\n});\ndocument.addEventListener(\"submit\", function (ev) {\n    if (ev.target instanceof HTMLFormElement) {\n        if (ev.target.dataset.formReplaceWithResult === \"true\") {\n            ev.preventDefault();\n            ev.stopImmediatePropagation();\n            var data_1 = new URLSearchParams();\n            var formData = new FormData(ev.target);\n            formData.forEach(function (v, k, p) {\n                data_1.append(k, v.toString());\n            });\n            fetch(ev.target.action, { method: 'post', body: data_1 })\n                .then(function (r) { return r.text(); })\n                .then(function (html) {\n                if (ev.target instanceof HTMLFormElement) {\n                    ev.target.outerHTML = html;\n                }\n            });\n            return false;\n        }\n    }\n    return true;\n});\n\n\n//# sourceURL=webpack:///./ts/src/site.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./ts/src/site.ts");
/******/ 	
/******/ })()
;